<html>

<head>
  <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>网络攻击与防御课程复习笔记 | 3ND</title>
<link rel="shortcut icon" href="https://3nd.xyz/favicon.ico?v=1627821697412">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://3nd.xyz/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="网络攻击与防御课程复习笔记 | 3ND - Atom Feed" href="https://3nd.xyz/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="- 考试相关 -


考核形式：平时 50% + 期末 50%

平时：课堂问答、作业 + 报告
期末：笔试（闭卷，多代码分析，需实践）



考题类型：

论述题（30%） 3 * 10'
材料分析题（20%） 1 * 20'
代码分析题..." />
    <meta name="keywords" content="Course" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <!--<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>-->
    <script src="/media/highlight.min.js"></script>
</head>

<body>
  <div class="main">
    <div class="main-content">
      <div class="site-header">
  <a href="https://3nd.xyz">
  <img class="avatar" src="https://3nd.xyz/images/avatar.png?v=1627821697412" alt="">
  </a>
  <h1 class="site-title">
    3ND
  </h1>
  <p class="site-description">
    夏が終わった
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/inspiringz" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              网络攻击与防御课程复习笔记
            </h2>
            <div class="post-info">
              <span>
                2020-06-10
              </span>
              <span>
                24 min read
              </span>
              <span class="page-view" key="20200610195334" title="网络攻击与防御课程复习笔记">
              </span>
              
                <a href="https://3nd.xyz/tag/course/" class="post-tag">
                  # Course
                </a>
                
            </div>
            
                <div class="post-content-wrapper">
                  <div class="post-content">
                    <p><strong>- 考试相关 -</strong></p>
<ul>
<li>
<p>考核形式：平时 50% + 期末 50%</p>
<ul>
<li>平时：课堂问答、作业 + 报告</li>
<li>期末：笔试（闭卷，多代码分析，需实践）</li>
</ul>
</li>
<li>
<p>考题类型：</p>
<ul>
<li>论述题（<code>30%</code>） 3 * 10'</li>
<li>材料分析题（<code>20%</code>） 1 * 20'</li>
<li>代码分析题（<code>50%</code>） 1 * 20'（Web） + 1 * 30'（BIN）</li>
</ul>
</li>
<li>
<p>分值分布：</p>
<ul>
<li>Web 40'</li>
<li>BIN 40'</li>
<li>Mobile 20'</li>
</ul>
</li>
</ul>
<h2 id="0x01-web-security">0x01 Web Security</h2>
<h3 id="owasp-top-10">OWASP TOP 10</h3>
<p>开放式 Web 应用程序安全项目（OWASP，Open Web Application Security Project）是一个非盈利的全球性安全组织，致力于应用软件的安全研究。使命是使应用软件更加安全，使企业组织能够对应用安全风险做出更清晰的决策。</p>
<p>&gt; http://www.owasp.org.cn/owasp-project/2017-owasp-top-10</p>
<figure data-type="image" tabindex="1"><img src="https://3nd.xyz/post-images/move/2020-06-10-20-11-10.png" alt="" loading="lazy"></figure>
<h4 id="a1-注入">A1 注入</h4>
<p>将<strong>不受信任的数据</strong>作为命令或查询的一部分发送到解析器时，会产生诸如 SQL 注入、NoSQL 注入、OS 注入和 LDAP 注入的注入缺陷。攻击者的恶意数据可以诱使解析在没有适当授权的情况下执行非预期命令或访问数据。</p>
<figure data-type="image" tabindex="2"><img src="https://3nd.xyz/post-images/move/2020-06-10-20-23-00.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="3"><img src="https://3nd.xyz/post-images/move/2020-06-10-20-24-03.png" alt="" loading="lazy"></figure>
<p>简单说，ORM 就是通过实例对象的语法，完成关系型数据库的操作的技术，是&quot;对象-关系映射&quot;（Object/Relational Mapping） 的缩写。ORM 把数据库映射成对象。</p>
<pre><code>数据库的表（table） --&gt; 类（class）
记录（record，行数据）--&gt; 对象（object）
字段（field）--&gt; 对象的属性（attribute）
</code></pre>
<p>参考链接：<a href="http://www.ruanyifeng.com/blog/2019/02/orm-tutorial.html">ORM 实例教程</a></p>
<h4 id="a2-失效的身份认证">A2 失效的身份认证</h4>
<p>通常，通过错误使用应用程序的身份认证和会话管理功能，攻击者能够破译<strong>密码、密钥</strong>或<strong>会话令牌</strong>，或者利用其它开发缺陷来暂时性或永久性冒充其他用户的身份。</p>
<figure data-type="image" tabindex="4"><img src="https://3nd.xyz/post-images/move/2020-06-10-20-31-36.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="5"><img src="https://3nd.xyz/post-images/move/2020-06-10-20-32-29.png" alt="" loading="lazy"></figure>
<h4 id="a3-敏感数据泄露">A3 敏感数据泄露</h4>
<p>许多 Web 应用程序和 API 都无法正确保护敏感数据，例如：财务数据、医疗数据和 <strong>个人敏感信息（PII）</strong> 数据。攻击者可以通过窃取或修改未加密的数据来实施信用卡诈骗、身份盗窃或其他犯罪行为。未加密的敏感数据容易受到破坏，因此，我们需要对敏感数据加密，这些数据包括：传输过程中的数据（是否明文传输）、存储的数据（是否加密）以及浏览器的交互数据。</p>
<figure data-type="image" tabindex="6"><img src="https://3nd.xyz/post-images/move/2020-06-10-20-36-51.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="7"><img src="https://3nd.xyz/post-images/move/2020-06-10-20-38-59.png" alt="" loading="lazy"></figure>
<h4 id="a4-xml-外部实体xxe">A4 XML 外部实体（XXE）</h4>
<p>许多较早的或配置错误的 XML 处理器评估了 XML 文件中的外部实体引用。攻击者可以利用外部实体窃取使用 URI 文件处理器的内部文件和共享文件、监听内部扫描端口、执行远程代码和实施拒绝服务攻击。</p>
<figure data-type="image" tabindex="8"><img src="https://3nd.xyz/post-images/move/2020-06-10-20-40-37.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="9"><img src="https://3nd.xyz/post-images/move/2020-06-10-20-50-07.png" alt="" loading="lazy"></figure>
<h4 id="a5-失效的访问控制">A5 失效的访问控制</h4>
<p>未对通过身份验证的用户实施恰当的访问控制。攻击者可以利用这些缺陷访问未经授权的功能或数据，例如：访问其他用户的帐户、查看敏感文件、修改其他用户的数据、更改访问权限等。</p>
<p><img src="https://3nd.xyz/post-images/move/2020-06-10-20-59-56.png" alt="" loading="lazy"><br>
<img src="https://3nd.xyz/post-images/move/2020-06-10-20-59-43.png" alt="" loading="lazy"></p>
<h4 id="a6-安全配置错误">A6 安全配置错误</h4>
<p>安全配置错误是最常见的安全问题，这通常是由于不安全的默认配置、不完整的临时配置、开源云存储、错误的 HTTP 标头配置以及包含敏感信息的详细错误信息所造成的。因此，我们不仅需要对所有的操作系统、框架、库和应用程序进行安全配置，而且必须及时修补和升级它们。</p>
<figure data-type="image" tabindex="10"><img src="https://3nd.xyz/post-images/move/2020-06-10-21-01-58.png" alt="" loading="lazy"></figure>
<h4 id="a7-跨站脚本xss">A7 跨站脚本（XSS）</h4>
<p>当应用程序的新网页中包含<strong>不受信任的、未经恰当验证或转义</strong>的数据时，或者使用可以创建 HTML 或 JavaScript 的浏览器 API 更新现有的网页时，就会出现 XSS 缺陷。XSS 让攻击者能够在受害者的浏览器中执行脚本，并劫持用户会话、破坏网站或将用户重定向到恶意站点。</p>
<figure data-type="image" tabindex="11"><img src="https://3nd.xyz/post-images/move/2020-06-10-21-04-15.png" alt="" loading="lazy"></figure>
<h4 id="a8-不安全的反序列化">A8 不安全的反序列化</h4>
<p>不安全的反序列化会导致远程代码执行。即使反序列化缺陷不会导致远程代码执行，攻击者也可以利用它们来执行攻击，包括：重播攻击、注入攻击和特权升级攻击。</p>
<figure data-type="image" tabindex="12"><img src="https://3nd.xyz/post-images/move/2020-06-10-21-05-52.png" alt="" loading="lazy"></figure>
<h4 id="a9-使用含有已知漏洞的组件">A9 使用含有已知漏洞的组件</h4>
<p>组件（例如：库、框架和其他软件模块）拥有和应用程序相同的权限。如果应用程序中含有已知漏洞的组件被攻击者利用，可能会造成严重的数据丢失或服务器接管。同时，使用含有已知漏洞的组件的应用程序和 API 可能会破坏应用程序防御、造成各种攻击并产生严重影响。</p>
<figure data-type="image" tabindex="13"><img src="https://3nd.xyz/post-images/move/2020-06-10-21-06-58.png" alt="" loading="lazy"></figure>
<h4 id="a10-不足的日志记录和监控">A10 不足的日志记录和监控</h4>
<p>不足的日志记录和监控，以及事件响应缺失或无效的集成，使攻击者能够进一步攻击系统、保持持续性或转向更多系统，以及篡改、提取或销毁数据。大多数缺陷研究显示，缺陷被检测出的时间超过 200 天，且通常通过外部检测方检测，而不是通过内部流程或监控检测。</p>
<figure data-type="image" tabindex="14"><img src="https://3nd.xyz/post-images/move/2020-06-10-21-08-22.png" alt="" loading="lazy"></figure>
<h3 id="代码审计">代码审计</h3>
<figure data-type="image" tabindex="15"><img src="https://3nd.xyz/post-images/move/2020-06-10-21-16-03.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="16"><img src="https://3nd.xyz/post-images/move/2020-06-10-21-17-10.png" alt="" loading="lazy"></figure>
<h3 id="渗透测试">渗透测试</h3>
<p>渗透测试（Pentration Testing）：一种通过模拟攻击者的技术与方法，挫败目标系统的安全控制措施并获取访问控制权的安全测试方法。</p>
<p>渗透测试执行标准（<code>PTES</code>: Pentration Testing Execution Standard）：</p>
<ol>
<li><strong>前期交互</strong>阶段（Pre-Engagement Interaction）</li>
</ol>
<p>确定渗透测试范围、目标、限制条件与服务合同细节。</p>
<ol start="2">
<li><strong>情报收集</strong>阶段（Information Gathering）</li>
</ol>
<p>获取目标网络拓扑、系统配置、安全防御措施等信息。</p>
<ol start="3">
<li><strong>威胁建模</strong>阶段（Threat Modeling）</li>
</ol>
<p>针对获取的信息进行威胁建模与攻击规划。</p>
<ol start="4">
<li><strong>漏洞分析</strong>阶段（Vulnerability Analysis）</li>
</ol>
<p>综合分析汇总的情报信息，从漏扫结果、服务查点信息等，找出可实施攻击的点。</p>
<ol start="5">
<li><strong>渗透攻击</strong>阶段（Exploitation）</li>
</ol>
<p>利用找出的系统漏洞入侵系统，获取访问控制权限。</p>
<ol start="6">
<li><strong>后渗透</strong>阶段（Post Exploitation）</li>
</ol>
<p>根据目标组织业务经营模式、保护资产形式等自主设计攻击目标，寻找客户组织最具价值和尝试安全保护的信息和资产，最终实施能造成重要业务影响的攻击。</p>
<ol start="7">
<li><strong>报告</strong>阶段（Reporting）</li>
</ol>
<p>凝聚所有阶段获取到的关键情报信息、探测和发掘出的系统安全漏洞、成功的渗透过程，同时站在防御者角度上分析安全体系中最薄弱的环节及修补与升级技术方案。</p>
<h3 id="权限提升">权限提升</h3>
<p>利用操作系统或者应用软件中的程序错误、设计缺陷或配置不当来获取受保护资源的高级访问权限。</p>
<h4 id="windows">Windows</h4>
<p>一般提权步骤：</p>
<ol>
<li>
<p>获取一个低权限 shell</p>
</li>
<li>
<p>利用 MSF Meterpreter getsystem 进行提权</p>
</li>
<li>
<p>MSF 中利用 Windows 版本提权漏洞</p>
</li>
<li>
<p>systeminfo 查看安装了哪些补丁</p>
</li>
<li>
<p>查找相关提权 exp</p>
</li>
<li>
<p>应用程序提权 Serv-u、Mysql ...</p>
</li>
</ol>
<p>常见提权手段：</p>
<ul>
<li>内核漏洞提权（Win32k.sys）</li>
<li>操作系统漏洞<br>
DLL 劫持、窃取 Token、窃取管理员密码、可执行文件路径未被引号包裹、允许非特权用户以 system 权限运行 MSI 文件 AlwaysInstallElevated
<ul>
<li>
<p><strong>DLL 劫持</strong><br>
通过劫持某些以高权限启动的程序中导入的动态链接库，达到以高权限执行恶意操作的目的。<br>
由于可执行模块的输入表只包含 DLL 名而没有它的路径名，因此加载程序会在磁盘中寻找 DLL，顺序为：</p>
<ul>
<li>当前文件夹下 =&gt; 系统目录（C:\system32）=&gt; 环境变量各目录（$PATH）</li>
</ul>
</li>
<li>
<p><strong>窃取 Windows Access Token</strong><br>
access token（访问令牌）是 Windows 安全性的一个概念，包含此登录会话的安全信息。用户登录时，系统创建一个访问令牌，然后以该用户身份运行的所有进程都拥有一个该令牌的拷贝。该令牌唯一表示该用户、用户组和用户权限（类似 Cookie）。<br>
通过窃取高权限用户的 Token，可以获得高权限。<br>
工具；<a href="https://github.com/0xbadjuju/Tokenvator">Tokenvator</a></p>
</li>
<li>
<p><strong>可执行文件路径未被引号包裹</strong><br>
假如一个服务（注册表等的记录值）的名称中包含空格，但没有引号包裹</p>
<pre><code>C:\Program Files\Target.exe
</code></pre>
<p>当 Windows 尝试启动服务时，会按照如下顺序：</p>
<ul>
<li>C:\Program.exe</li>
<li>C:\Program Files.exe</li>
<li>C:\Program Files\Target.exe</li>
</ul>
<p>假如把恶意 exe 放在这些路径下，那么系统级服务重启时，便会以高权限执行任意文件。</p>
</li>
<li>
<p><strong>AlwaysInstallElevated</strong><br>
<strong>&gt;</strong> <a href="https://3gstudent.github.io/3gstudent.github.io/%E5%88%A9%E7%94%A8AlwaysInstallElevated%E6%8F%90%E6%9D%83%E7%9A%84%E6%B5%8B%E8%AF%95%E5%88%86%E6%9E%90/">利用 AlwaysInstallElevated 提权的测试分析</a><br>
微软允许非授权用户以 SYSTEM 权限运行安装文件（MSI）, 在测试环境启用 AlwaysInstallElevated，命令如下：</p>
<pre><code class="language-sh">reg add HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1
reg add HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated /t REG_DWORD /d 1
</code></pre>
</li>
</ul>
</li>
<li>应用程序漏洞<br>
SMB、MySQL、Serv-U、etc.</li>
</ul>
<h4 id="linux-">Linux（$-&gt;#）</h4>
<p>一般步骤：</p>
<ol>
<li>查看内核版本</li>
</ol>
<pre><code>uname -a
cat /proc/version
</code></pre>
<ol start="2">
<li>
<p>检查是否有配置不当，如低权限用户对高权限用户的读写权，或者某些 SUID 程序可执行 bash</p>
</li>
<li>
<p>应用程序提权（Apache、Tomcat、MySQL、Redis、MongoDB）</p>
</li>
</ol>
<p>常见提权手段：</p>
<ul>
<li>
<p>内核提权</p>
<ul>
<li><strong>脏牛漏洞（CVE-2016-5195）</strong><br>
Linux 内核的内存子系统在处理写时复制（copy-on-write，COW）时产生了条件竞争。恶意用户可利用该漏洞，对只读内存映射进行写访问来获取最高权限。</li>
</ul>
</li>
<li>
<p>系统提权</p>
<ul>
<li>
<p><strong>SUID 程序提权</strong><br>
<code>SUID</code>（设置用户 ID）是赋予文件的一种权限，它会出现在文件拥有者权限的执行位上，<strong>具有这种权限的文件会在其执行时，使调用者暂时获得该文件拥有者的权限。</strong><br>
但是，如果某些现有的二进制文件和实用程序具有 SUID 权限的话，就可以在执行时将权限提升为 root。具有提权功能的Linux可执行文件包括：</p>
<pre><code>Nmap、Vim、find、Bash、More、Less、Nano、cp
</code></pre>
<p>以下命令可以找到正在系统上运行的所有 SUID 可执行文件。准确的说，这个命令将从 <code>/</code> 目录中查找具有 SUID 权限位且属主为 root 的文件并输出它们，然后将所有错误重定向到 <code>/dev/null</code>(或称空设备，在类 Unix 系统中是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个 EOF），从而仅列出该用户具有访问权限的那些二进制文件。</p>
<pre><code class="language-sh">find / -user root -perm -4000 -print 2&gt;/dev/null
find / -perm -u=s -type f 2&gt;/dev/null
find / -user root -perm -4000 -exec ls -ldb {} ;
</code></pre>
<p>以上所有二进制文件都将以 root 用户权限来执行，因为它们的权限中包含 <code>s</code>，并且它们的属主为 root。</p>
</li>
<li>
<p><strong>修改用户属性（文件权限配置不当）</strong></p>
</li>
<li>
<p><strong>修改 /etc/passwd</strong><br>
用户口令优先读取 /etc/passwd，而后才是 /etc/shadow，假如拥有 /etc/passwd 的写权限的话，则可修改：</p>
<pre><code>#用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 shell
root:x:0:0:root:/root:/bin/bash
</code></pre>
<p>为：</p>
<pre><code>#用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 shell
root:[passwd encrypted]:0:0:root:/root:/bin/bash
</code></pre>
</li>
<li>
<p><strong>修改 root 用户 ssh 密钥</strong><br>
加入对 /root/.ssh/ 有写权限，则可将自己的 ssh 密钥写入 /root/.ssh/authorized_keys，实现 ssh 免密码登录。如 Redis 未授权访问漏洞写入 ssh 密钥（Redis 一般以 root 权限启动）。</p>
</li>
<li>
<p><strong>通配符提权</strong><br>
&gt; <a href="https://www.freebuf.com/articles/system/176255.html">利用通配符进行 Linux 本地提权</a><br>
<img src="https://3nd.xyz/post-images/move/2020-06-10-23-23-26.png" alt="" loading="lazy"></p>
</li>
<li>
<p><strong>应用程序提权</strong></p>
</li>
</ul>
</li>
</ul>
<h4 id="数据库-udf-提权">数据库 UDF 提权</h4>
<p><strong>&gt;</strong> <a href="https://www.cnblogs.com/litlife/p/9030673.html">udf 提权原理详解</a></p>
<p><code>UDF</code>: User-defined function，即用户自定义函数。是通过添加新函数，对 MySQL 的功能进行扩充，性质就象使用本地 MySQL 函数如 abs() 或 concat()。udf 在 MySQL <code>5.1</code> 以后的版本中，存在于 <code>mysql/lib/plugin</code> 目录下，文件后缀为 <code>.dll</code>，常用 C 语言编写。</p>
<p>前提条件：</p>
<ol>
<li>
<p>获得 root 账户密码</p>
</li>
<li>
<p>数据库开启 plugin</p>
</li>
<li>
<p>数据库监听公网</p>
</li>
</ol>
<p><strong>- 如何防御提权 -</strong></p>
<ul>
<li>
<p>及时打补丁</p>
</li>
<li>
<p>启动 Web、DB 服务时以低权限启动（最小权限原则）</p>
</li>
<li>
<p>服务只监听 127.0.0.1 （不要开放在公网）</p>
</li>
</ul>
<h2 id="0x02-reverse-enginee">0x02 Reverse Enginee</h2>
<p>要求：能分析汇编语言代码，能书写简单的汇编代码</p>
<pre><code>字节序
汇编基础（给定代码能说明其含义）
调用约定（相关的汇编代码分析和栈的变化情况）
简单的软件保护技术举例
Windows 内核管理
</code></pre>
<h3 id="逆向工程概述">逆向工程概述</h3>
<h4 id="字节序与编码">字节序与编码</h4>
<p>&gt; <a href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html">理解字节序</a></p>
<p>计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。</p>
<p>举例来说，数值 0x2211 使用两个字节储存：高位字节是 0x22，低位字节是 0x11。</p>
<ul>
<li>
<p>大端字节序：<strong>低地址存放高字节，高地址存放低字节</strong>，这是人类读写数值的方法。</p>
</li>
<li>
<p>小端字节序：<strong>低地址存放低字节，高地址存放高字节</strong>，即以 0x1122 形式储存。</p>
</li>
</ul>
<p>同理，0x1234567 的大端字节序和小端字节序的写法如下图：</p>
<figure data-type="image" tabindex="17"><img src="https://3nd.xyz/post-images/move/2020-06-11-15-24-22.png" alt="" loading="lazy"></figure>
<p>计算机电路先处理低位字节，效率比较高，因为计算都是从低位开始的。所以，计算机的内部处理都是小端字节序。</p>
<p>对于 char[] 字符数组，在内存中连续，不管是大端序还是小端序，存储顺序都是一样的。</p>
<p>栈区填充：</p>
<p>循环执行将 EAX 的值填入 EDI 对应的内存空间中：</p>
<pre><code class="language-assmble">lea edi,dword ptr ss:[ebp-50]   ;EDI存放循环操作起始地址
mov ecx,14                      ;循环次数
mov eax,0xCCCCCCCC              ;填入的值
rep stosd
</code></pre>
<ul>
<li>
<p>rep 以 ECX 为计数器。</p>
</li>
<li>
<p>stosb / stosw / stosd 把 AL / AX / EAX 的值填入 EDI 指向的内存空间中，同时 EDI 向标志寄存器 DF 的方向增加或减少。</p>
</li>
<li>
<p>CC 指令：INT 3 中断的机器码。</p>
</li>
</ul>
<p>编码相关：</p>
<ul>
<li>
<p>ANSI 字符集：1 Byte、Unicode 字符集：2 Byte。</p>
</li>
<li>
<p>Window API 最终都要转化成 Unicode 。</p>
</li>
<li>
<p>\Windows\System32 下存放原生的 64 位映像文件。</p>
</li>
<li>
<p>\Windows\SysWOW64 下存放 32 位的系统文件。WOW：Windows-on-Windows 64-bit，为 64 位 Windows OS 的子系统。</p>
</li>
</ul>
<h4 id="栈的脏数据">栈的脏数据</h4>
<p>函数栈退出以后，原有栈空间的局部变量不会被自动清除，成为栈的<strong>噪音</strong>或<strong>脏数据</strong>。</p>
<h4 id="汇编基础">汇编基础</h4>
<ul>
<li>
<p>栈（stack）：从高地址向低地址生长。</p>
</li>
<li>
<p>栈帧（stack frame）：程序运行时栈中分配的内存块，专门用于特定的函数调用。</p>
</li>
</ul>
<p>栈帧的大致结构：</p>
<pre><code class="language-asm">; 函数序言
push    ebp        ;函数开始（使用 EBP 前先把已有值保存到栈中）
mov     ebp,esp    ;保存当前 ESP 到 EBP 中
sub     esp,0x10
​
; ……
; 函数体
; ……              ;无论 ESP 怎么变化，EBP 都保持不变，可以安全访问函数的局部变量、参数
​
; 函数尾声
mov     esp,ebp   ;将函数起始地址返回到 ESP 中
pop     ebp       ;函数返回前弹出保存在栈中的 EBP 值
ret               ;函数停止
</code></pre>
<p>调用一个函数时的操作步骤：</p>
<ol>
<li>
<p>Caller 将 Callee 所需<strong>参数</strong>放入函数所采用的<strong>调用约定</strong>的指定位置。</p>
</li>
<li>
<p>Caller 将控制权转交给 Callee ，然后<strong>返回地址</strong>被保存到程序栈或 CPU 寄存器中。</p>
</li>
<li>
<p>Callee 为局部变量分配空间。</p>
</li>
<li>
<p>Callee 执行操作。</p>
</li>
<li>
<p>Callee 完成操作，释放局部变量的栈空间。</p>
</li>
<li>
<p>Callee 将控制权返还给 Caller（ret）。</p>
</li>
</ol>
<p><strong>AT&amp;T 汇编指令 enter、leave、call、ret：</strong></p>
<p><code>enter</code> 相当于 Intel 中的：</p>
<pre><code class="language-asm">push    ebp
mov     ebp,esp
</code></pre>
<p><code>leave</code> 是 enter 的相反的过程：</p>
<pre><code class="language-asm">mov     esp,ebp
pop     ebp
</code></pre>
<p><code>call</code> 保存当前 EIP 后修改 EIP 的值，相当于：</p>
<pre><code class="language-asm">push    eip
mov     eip,&lt;function address&gt;
</code></pre>
<p><code>ret</code> 只要恢复 EIP，相当于：</p>
<pre><code class="language-asm">pop     eip
</code></pre>
<p>漏洞代码：</p>
<pre><code class="language-c">//vuln.c
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main(int argc, char* argv[]) {
        /* [1] */ char buf[256];
        /* [2] */ strcpy(buf,argv[1]);
        /* [3] */ printf(&quot;Input:%s\n&quot;,buf);
        return 0;
}
</code></pre>
<p>反汇编：</p>
<pre><code class="language-asm">(gdb) disassemble main
Dump of assembler code for function main:
   0x08048414 &lt;+0&gt;:	push   %ebp                    //backup caller's ebp
   0x08048415 &lt;+1&gt;:	mov    %esp,%ebp               //set callee's ebp to esp
   0x08048417 &lt;+3&gt;:	and    $0xfffffff0,%esp        //栈对齐
   0x0804841a &lt;+6&gt;:	sub    $0x110,%esp             //stack space for local variables
   0x08048420 &lt;+12&gt;:	mov    0xc(%ebp),%eax          //eax = argv
   0x08048423 &lt;+15&gt;:	add    $0x4,%eax               //eax = &amp;argv[1]
   0x08048426 &lt;+18&gt;:	mov    (%eax),%eax             //eax = argv[1]
   0x08048428 &lt;+20&gt;:	mov    %eax,0x4(%esp)          //strcpy arg2 
   0x0804842c &lt;+24&gt;:	lea    0x10(%esp),%eax         //eax = 'buf'
   0x08048430 &lt;+28&gt;:	mov    %eax,(%esp)             //strcpy arg1
   0x08048433 &lt;+31&gt;:	call   0x8048330 &lt;strcpy@plt&gt;  //call strcpy
   0x08048438 &lt;+36&gt;:	mov    $0x8048530,%eax         //eax = format str &quot;Input:%s\n&quot;
   0x0804843d &lt;+41&gt;:	lea    0x10(%esp),%edx         //edx = buf
   0x08048441 &lt;+45&gt;:	mov    %edx,0x4(%esp)          //printf arg2
   0x08048445 &lt;+49&gt;:	mov    %eax,(%esp)             //printf arg1
   0x08048448 &lt;+52&gt;:	call   0x8048320 &lt;printf@plt&gt;  //call printf
   0x0804844d &lt;+57&gt;:	mov    $0x0,%eax               //return value 0
   0x08048452 &lt;+62&gt;:	leave                          //mov ebp, esp; pop ebp; 
   0x08048453 &lt;+63&gt;:	ret                            //return =&gt; pop eip
End of assembler dump.
</code></pre>
<p>堆栈布局：</p>
<figure data-type="image" tabindex="18"><img src="https://3nd.xyz/post-images/move/2020-06-11-23-15-16.png" alt="" loading="lazy"></figure>
<h4 id="调用约定">调用约定</h4>
<p>调用约定：指定调用方放置函数所需参数的具体位置。</p>
<figure data-type="image" tabindex="19"><img src="https://3nd.xyz/post-images/move/2020-06-11-15-51-28.png" alt="" loading="lazy"></figure>
<p>函数支持可变参数的前提：调用方清理堆栈。</p>
<p>注意：</p>
<ul>
<li>x86 __fastcall 前两个参数传入 ECX 和 EDX。</li>
<li>x64 __fastcall 前四个参数传入 RCX、EDX、R8、R9。</li>
</ul>
<p>IDA 中，把参数和局部变量自动识别成类似 arg_0、var_4 的形式：</p>
<ul>
<li>
<p>arg_ 代表参数，都是正数。</p>
</li>
<li>
<p>var_ 代表局部变量，都是负数。</p>
</li>
</ul>
<p><strong>Q：如何区分是 __cdecl 还是 __stdcall ?</strong></p>
<ul>
<li>__cdecl 调用方清理堆栈（外，适合参数变量可变）：<pre><code>call    &lt;function_name&gt;
add     esp,10h
</code></pre>
</li>
<li>__stdcall 被调用方清理堆栈（内，适合参数个数固定）：<pre><code>retn    10h
</code></pre>
</li>
</ul>
<p><strong>Others：</strong></p>
<p>系统调用？从用户模式进入内核模式。</p>
<p>Linux x86 使用 int 0x80 或 sysenter 指令。其他 x86 可能只有 sysenter 指令。</p>
<p>非优化编译器使用 EBP 寻址。</p>
<p>优化：使用 ESP 寻址。（减少代码，提高速度）</p>
<h3 id="软件保护技术基础">软件保护技术基础</h3>
<p>常见的软件保护技术：</p>
<ol>
<li>
<p><strong>序列号</strong></p>
</li>
<li>
<p><strong>警告窗口（Nag）</strong></p>
</li>
<li>
<p><strong>时间限制</strong></p>
</li>
<li>
<p><strong>菜单功能限制</strong></p>
</li>
<li>
<p><strong>KeyFile 保护</strong></p>
</li>
<li>
<p><strong>网络验证</strong></p>
</li>
<li>
<p><strong>只运行一个实例</strong></p>
</li>
</ol>
<h3 id="windows-内核基础">Windows 内核基础</h3>
<p>用户态（Ring 3）、核心态（Ring 0）。用户态下所有动态链接库（USER32.DLL、KERNEL32.DLL、GDI32.DLL）都会经由 NTDLL.DLL 映射到核心态执行体。</p>
<figure data-type="image" tabindex="20"><img src="https://3nd.xyz/post-images/move/2020-06-11-16-42-08.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>USER32 ：用户界面相关应用程序接口。</p>
</li>
<li>
<p>GDI32.DLL ：图形用户界面相关程序。</p>
</li>
<li>
<p>KERNEL32.DLL ：内存管理、数据 I/O 操作、中断处理。</p>
</li>
</ul>
<p>UEFI（Unified Extensible Firmware Interface, 同意的可扩展固件接口）相当于一个微型 OS，能直接读取分区中的文件。不需要 MBR（主引导记录）</p>
<figure data-type="image" tabindex="21"><img src="https://3nd.xyz/post-images/move/2020-06-11-16-45-28.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>smss.exe ：会话管理器子系统，第一个用户模式进程。</p>
</li>
<li>
<p>csrss.exe ：客户端/服务器运行时子系统。主要负责 Win32 控制台的处理和界面关闭，是关键的系统操作。</p>
</li>
<li>
<p>winlogon ：用户的登陆和注销支持。</p>
</li>
<li>
<p>lsass ：本地安全授权子系统。</p>
</li>
<li>
<p>services.exe ：服务子系统。</p>
</li>
</ul>
<h2 id="0x03-mobile-network-security">0x03 Mobile Network Security</h2>
<pre><code>移动网络的分类和安全风险
WLAN 安全机制-- WEP，IEEE 802.11i（WPA、WPA2、CCMP、TKIP、认证密钥交换、四步握手）
移动通信安全机制-- GSM 3G, 4G
</code></pre>
<h3 id="wlan-安全机制">WLAN 安全机制</h3>
<h4 id="wep">WEP</h4>
<p>WEP 是 Wired Equivalent Privacy的 简称，<strong>有线等效保密（WEP）协议</strong>是对在两台设备间无线传输的数据进行加密的方式，用以防止非法用户窃听或侵入无线网络。</p>
<ul>
<li>加密过程</li>
</ul>
<ol>
<li>生成一个 <code>IV</code>（24 位），与共享密钥 <code>SK</code>（40 位）连接在一起作为种子密钥。使用 <code>RC4</code> 算法生成密钥流。</li>
<li>使用数据冗余校验算法 <code>CRC32</code> （低配版的哈希函数）计算明文数据的 <code>ICV</code>。</li>
<li>明文和 <code>ICV</code> 连接起来，与密钥流异或得到密文。</li>
</ol>
<figure data-type="image" tabindex="22"><img src="https://3nd.xyz/post-images/move/2020-06-11-21-38-30.png" alt="" loading="lazy"></figure>
<ul>
<li>解密过程</li>
</ul>
<figure data-type="image" tabindex="23"><img src="https://3nd.xyz/post-images/move/2020-06-11-21-42-02.png" alt="" loading="lazy"></figure>
<p>加密算法是：明文 || ICV ⊕ 密钥流 → 密文</p>
<p>解密算法是：密文 ⊕ 密钥流 → 明文 || ICV</p>
<p>ICV 这时候就有用了，通过同样的算法（CRC32）计算收到的明文的 ICV'，验证一下 ICV 是否和 ICV' 相同，以验证数据完整性：</p>
<ul>
<li>
<p>相同，则认为数据未经篡改。</p>
</li>
<li>
<p>不相同，则认为数据不完整，丢弃这个包。</p>
</li>
</ul>
<p><strong>- 安全缺陷 -</strong></p>
<ol>
<li>
<p><strong>RC4 算法的使用</strong><br>
RC4 存在大量的弱密钥（每 256 个 RC4 密钥中就有 1 个是弱密钥）。</p>
</li>
<li>
<p><strong>WEP 没有抗重放机制</strong><br>
WEP 协议帧中无序列号，无法确定协议帧的顺序。<br>
WEP 的完整性保护只应用于数据载荷，而不保护源地址、目的地址等，攻击者可以伪造这些信息，进行重放。</p>
</li>
<li>
<p><strong>SV 的产生与分发</strong></p>
</li>
</ol>
<ul>
<li>
<p>IV(24) SK(40) 相当于 5 字符，10 位十六进制。</p>
</li>
<li>
<p>IV(24) SK(104) 相当于 13 字符，26 位十六进制。</p>
</li>
</ul>
<p>对于 SK，厂商一般提供两种方式：</p>
<ul>
<li>用户直接输入 5 或 13 个字符（用户一般这么干）</li>
<li>或者输入比特（或十六进制），比较麻烦</li>
</ul>
<p>考虑可打印字符有的个数，生成器的设计缺陷导致 40 比特的 SK 只有 21 比特的安全性（<strong>穷举</strong>）</p>
<p>普通用户喜欢用姓名、生日、电话等作为密钥词组（<strong>字典</strong>）</p>
<p>SK 为 WLAN 用户共享，且很少变动（<strong>泄露</strong>）</p>
<ol start="4">
<li>
<p><strong>IV 空间太小</strong><br>
使用 IV 的目的：为每个数据包创建一个新的、不重复的<strong>数据包密钥</strong>。<br>
若使用相同的 IV || SK 加密两个消息，则 C_1 ⊕ C_2 = P_1 ⊕ P_2。若一个明文已知，那么另一个明文也暴露了。<br>
24 bit 的 IV 有 2^24 种可能，假设 IV 的生成是完全随机的，结合密码学中生日攻击知识，当发送的包超过 2^12 = 5000 个时，IV 就会开始重复，很快就会出现 IV 冲突。</p>
</li>
<li>
<p><strong>CRC32 是线性的</strong><br>
<img src="https://3nd.xyz/post-images/move/2020-06-11-21-51-05.png" alt="" loading="lazy"><br>
在 k 未知的情况下，可任意篡改未知明文的密文，且能保证 ICV 值的正确性。</p>
</li>
</ol>
<p><strong>- 认证机制 -</strong></p>
<p><code>AP</code>: Access Point, 接入点</p>
<ul>
<li>
<p>开放系统认证：直接把密钥以明文的形式发给认证方（路由器）</p>
</li>
<li>
<p>共享密钥认证：挑战/响应机制：</p>
<ul>
<li>客户端向 AP 发送认证请求。</li>
<li>AP 向客户端发送明文挑战帧。</li>
<li>客户端用 WEP 密钥加密该挑战，并发送给 AP。</li>
<li>AP 发送认证响应。</li>
</ul>
</li>
</ul>
<h4 id="ieee-80211i">IEEE 802.11i</h4>
<p><strong>-加密机制-<code>TKIP</code> 暂时密钥完整性协议 -</strong></p>
<p>使 WEP 设备能够通过软件升级来支持 TKIP （既要解决兼容，又要解决 WEP 的安全缺陷），是包裹在 WEP 外的一套算法。</p>
<p>TKIP 的改进：</p>
<ul>
<li>
<p>IV：24 → 48</p>
</li>
<li>
<p>SK：40 → 104</p>
</li>
<li>
<p>引入 4 个新算法</p>
<ul>
<li>单包密钥生成算法：防止弱密钥的产生</li>
<li>MIC：防止数据被非法篡改</li>
<li>具有序列功能的 IV ：抗重放</li>
<li>Rekeying：防止 IV 重用</li>
</ul>
</li>
</ul>
<p>加密过程：</p>
<figure data-type="image" tabindex="24"><img src="https://3nd.xyz/post-images/move/2020-06-11-22-12-32.png" alt="" loading="lazy"></figure>
<p>解密过程：</p>
<figure data-type="image" tabindex="25"><img src="https://3nd.xyz/post-images/move/2020-06-11-22-13-51.png" alt="" loading="lazy"></figure>
<p>Q：在 IEEE802.11i 协议中并没有使用共享密钥作为加密和解密的密钥，那么加密和解密的密钥是如何生成的？</p>
<p>A：IEEE802.11i 的认证和密钥交换协议（AKE）</p>
<ul>
<li><strong>AKE 协议流程与结构</strong></li>
<li><strong>四步握手协议</strong></li>
</ul>
<p>两种模式：</p>
<ul>
<li>预共享密钥模式（WPA-PSK/WPA2-PSK，个人版）</li>
<li><strong>企业模式</strong></li>
</ul>
<figure data-type="image" tabindex="26"><img src="https://3nd.xyz/post-images/move/2020-06-11-22-41-25.png" alt="" loading="lazy"></figure>
<p>申请者（STA，相当于你的设备），认证者（AP，相当于路由器），认证服务器（AS）</p>
<ul>
<li>
<p>APnonce：AP 生成的随机数</p>
</li>
<li>
<p>Snonce：申请者生成的随机数</p>
</li>
<li>
<p>APA：AP 地址</p>
</li>
<li>
<p>SA：申请者地址</p>
</li>
<li>
<p>PRF：伪随机函数</p>
</li>
<li>
<p>PMK：对主密钥</p>
</li>
<li>
<p>PTK：对瞬时（临时）密钥，最终用于加密单播数据的密钥。512 位，结构如下：</p>
</li>
</ul>
<figure data-type="image" tabindex="27"><img src="https://3nd.xyz/post-images/move/2020-06-11-22-51-14.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>GMK：组主密钥</p>
</li>
<li>
<p>GTK：组瞬时（临时）密钥，最终用于加密广播/组播数据的密钥。</p>
</li>
<li>
<p>MIC：消息认证码</p>
</li>
</ul>
<figure data-type="image" tabindex="28"><img src="https://3nd.xyz/post-images/move/2020-06-11-22-48-53.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="29"><img src="https://3nd.xyz/post-images/move/2020-06-11-22-49-00.png" alt="" loading="lazy"></figure>
<p>STA 通过网络发现找到 AP，与 AS 共享一个对主密钥 PMK，AS 将 PMK 安全传送到 AP。</p>
<ol>
<li>AP 生成一个随机数 APnonce，发送给 STA 。</li>
<li>STA 生成一个随机数 Snonce，利用 （APnonce, Snonce, PMK, APA, SA）生成对瞬时密钥 PTK。将 Snonce 和 MIC（由 PTK 中 KCK 生成）发送给 AP 。AP 收到 Snonce 和 MIC 后，使用相同的方法生成 PTK，并利用 PTK 中的 KCK 验证 MIC 。若验证失败，则结束过程。</li>
<li>验证成功后，AP 将 APnonce 和 MIC 发送给 STA 。</li>
<li>STA 收到后，执行相同的检查工作，确认 AP 和自己有相同的 PMK，确认成功后向 AP 回发一个 MIC 。</li>
</ol>
<h3 id="gsm">GSM</h3>
<figure data-type="image" tabindex="30"><img src="https://3nd.xyz/post-images/move/2020-06-11-23-04-31.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="https://3nd.xyz/post-images/move/2020-06-11-23-05-08.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="32"><img src="https://3nd.xyz/post-images/move/2020-06-11-23-05-19.png" alt="" loading="lazy"></figure>
<p><strong>- 参考 -</strong></p>
<p>[1] <a href="https://comydream.github.io/">ComyDream</a></p>

                  </div>
                  <div class="toc-container">
                    <div style="position: sticky;
                    top: 20px;">
                    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#0x01-web-security">0x01 Web Security</a>
<ul>
<li><a href="#owasp-top-10">OWASP TOP 10</a>
<ul>
<li><a href="#a1-%E6%B3%A8%E5%85%A5">A1 注入</a></li>
<li><a href="#a2-%E5%A4%B1%E6%95%88%E7%9A%84%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81">A2 失效的身份认证</a></li>
<li><a href="#a3-%E6%95%8F%E6%84%9F%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2">A3 敏感数据泄露</a></li>
<li><a href="#a4-xml-%E5%A4%96%E9%83%A8%E5%AE%9E%E4%BD%93xxe">A4 XML 外部实体（XXE）</a></li>
<li><a href="#a5-%E5%A4%B1%E6%95%88%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6">A5 失效的访问控制</a></li>
<li><a href="#a6-%E5%AE%89%E5%85%A8%E9%85%8D%E7%BD%AE%E9%94%99%E8%AF%AF">A6 安全配置错误</a></li>
<li><a href="#a7-%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%ACxss">A7 跨站脚本（XSS）</a></li>
<li><a href="#a8-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96">A8 不安全的反序列化</a></li>
<li><a href="#a9-%E4%BD%BF%E7%94%A8%E5%90%AB%E6%9C%89%E5%B7%B2%E7%9F%A5%E6%BC%8F%E6%B4%9E%E7%9A%84%E7%BB%84%E4%BB%B6">A9 使用含有已知漏洞的组件</a></li>
<li><a href="#a10-%E4%B8%8D%E8%B6%B3%E7%9A%84%E6%97%A5%E5%BF%97%E8%AE%B0%E5%BD%95%E5%92%8C%E7%9B%91%E6%8E%A7">A10 不足的日志记录和监控</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1">代码审计</a></li>
<li><a href="#%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95">渗透测试</a></li>
<li><a href="#%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87">权限提升</a>
<ul>
<li><a href="#windows">Windows</a></li>
<li><a href="#linux-">Linux（$-&gt;#）</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93-udf-%E6%8F%90%E6%9D%83">数据库 UDF 提权</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#0x02-reverse-enginee">0x02 Reverse Enginee</a>
<ul>
<li><a href="#%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0">逆向工程概述</a>
<ul>
<li><a href="#%E5%AD%97%E8%8A%82%E5%BA%8F%E4%B8%8E%E7%BC%96%E7%A0%81">字节序与编码</a></li>
<li><a href="#%E6%A0%88%E7%9A%84%E8%84%8F%E6%95%B0%E6%8D%AE">栈的脏数据</a></li>
<li><a href="#%E6%B1%87%E7%BC%96%E5%9F%BA%E7%A1%80">汇编基础</a></li>
<li><a href="#%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A">调用约定</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AF%E4%BB%B6%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80">软件保护技术基础</a></li>
<li><a href="#windows-%E5%86%85%E6%A0%B8%E5%9F%BA%E7%A1%80">Windows 内核基础</a></li>
</ul>
</li>
<li><a href="#0x03-mobile-network-security">0x03 Mobile Network Security</a>
<ul>
<li><a href="#wlan-%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6">WLAN 安全机制</a>
<ul>
<li><a href="#wep">WEP</a></li>
<li><a href="#ieee-80211i">IEEE 802.11i</a></li>
</ul>
</li>
<li><a href="#gsm">GSM</a></li>
</ul>
</li>
</ul>
</li>
</ul>

                  </div>
                  </div>
                </div>
          </article>
        </div>

        
          <div class="nearby-post" style="padding: 24px 32px;">
            <div class="prev-post" style="float: left;">
              <div class="aaa" style="
              margin-bottom: 24px;
              color: #343a40;
              font-weight: lighter;text-align: left;">上一篇</div>
              <a href="https://3nd.xyz/post/2020-06-15-network-x-review-md/">
                <h3 class="post-title" style="text-align: left;">
                  《计算机网络》(7) 复习笔记
                </h3>
              </a>
            </div>
            <div class="next-posts" style="float: right;">
              <div class="aaa" style="
              margin-bottom: 24px;
              color: #343a40;
              font-weight: lighter; text-align: right;">下一篇</div>
              <a href="https://3nd.xyz/post/2020-06-05-os-security-review/">
                <h3 class="post-title" style="
                text-align: right;">
                  操作系统安全课程复习笔记
                </h3>
              </a>
            </div>
          </div>
          

                

                                <div class="site-footer">
  
  <a class="rss" href="https://3nd.xyz/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

    </div>
  </div>

  <script>
    hljs.highlightAll();

    let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

    // This should probably be throttled.
    // Especially because it triggers during smooth scrolling.
    // https://lodash.com/docs/4.17.10#throttle
    // You could do like...
    // window.addEventListener("scroll", () => {
    //    _.throttle(doThatStuff, 100);
    // });
    // Only not doing it here to keep this Pen dependency-free.

    window.addEventListener("scroll", event => {
      let fromTop = window.scrollY;

      mainNavLinks.forEach((link, index) => {
        let section = document.getElementById(decodeURI(link.hash).substring(1));
        let nextSection = null
        if (mainNavLinks[index + 1]) {
          nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
        }
        if (section.offsetTop <= fromTop) {
          if (nextSection) {
            if (nextSection.offsetTop > fromTop) {
              link.classList.add("current");
            } else {
              link.classList.remove("current");
            }
          } else {
            link.classList.add("current");
          }
        } else {
          link.classList.remove("current");
        }
      });
    });
  </script>
<script src="/media/view-support.js"></script>
<script>
  window.Lazyload.js(['https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js', '//cdn.jsdelivr.net/npm/leancloud-storage@3.13.2/dist/av-min.js'], function () {
    var pageview = window.pageview(AV, {
      appId: 'HRVNDkHV80Fpk9M8c5GQqjwy-gzGzoHsz',
      appKey: 'nsyqncNCSWSOkkns1wvDlUrh',
      appClass: 'Gridea',
    });
    $('.page-view').each(function () {
      var $this = $(this);
      var key = $this.attr('key');
      var title = $this.attr('title');
      pageview.increase(key, title, function(view) {
        $("[key='" + key +"']").text(view+' views');
      });
    });
  });
</script>

</body>

</html>